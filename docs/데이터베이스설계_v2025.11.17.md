# ë°ì´í„°ë² ì´ìŠ¤ ì„¤ê³„ ê°€ì´ë“œ v1.1.0 ğŸ—„ï¸
**Girls Band Tabi - ë°ì´í„°ë² ì´ìŠ¤ ì•„í‚¤í…ì²˜**

**ìµœì‹  ì—…ë°ì´íŠ¸**: 2025ë…„ 11ì›” 17ì¼  
**ë²„ì „**: v1.1.0  
**ìƒíƒœ**: âœ… ìµœì‹   
**ëŒ€ìƒ**: ê°œë°œì, ë°ì´í„°ë² ì´ìŠ¤ ê´€ë¦¬ì, DevOps ì—”ì§€ë‹ˆì–´

## ëª©ì°¨

1. [ê°œìš”](#ê°œìš”)
2. [ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ ì•„í‚¤í…ì²˜](#ë°ì´í„°ë² ì´ìŠ¤-ìŠ¤í‚¤ë§ˆ-ì•„í‚¤í…ì²˜)
3. [PostgreSQL + PostGIS ì„¤ì •](#postgresql--postgis-ì„¤ì •)
4. [ì—”í‹°í‹° ê´€ê³„](#ì—”í‹°í‹°-ê´€ê³„)
5. [ê³µê°„ ë°ì´í„° ì„¤ê³„ íŒ¨í„´](#ê³µê°„-ë°ì´í„°-ì„¤ê³„-íŒ¨í„´)
6. [ë§ˆì´ê·¸ë ˆì´ì…˜ ì „ëµ & Flyway](#ë§ˆì´ê·¸ë ˆì´ì…˜-ì „ëµ--flyway)
7. [ì¸ë±ì‹± ì „ëµ](#ì¸ë±ì‹±-ì „ëµ)
8. [ì„±ëŠ¥ ê³ ë ¤ì‚¬í•­](#ì„±ëŠ¥-ê³ ë ¤ì‚¬í•­)
9. [ì¿¼ë¦¬ ìµœì í™”](#ì¿¼ë¦¬-ìµœì í™”)
10. [ë°ì´í„° ì‹œë”© & í…ŒìŠ¤íŠ¸ ë°ì´í„°](#ë°ì´í„°-ì‹œë”©--í…ŒìŠ¤íŠ¸-ë°ì´í„°)
11. [ì»¤ë„¥ì…˜ í’€ë§ (HikariCP)](#ì»¤ë„¥ì…˜-í’€ë§-hikaricp)
12. [ë°±ì—… & ìœ ì§€ë³´ìˆ˜](#ë°±ì—…--ìœ ì§€ë³´ìˆ˜)
13. [ì¼ë°˜ì ì¸ ê³µê°„ ì¿¼ë¦¬](#ì¼ë°˜ì ì¸-ê³µê°„-ì¿¼ë¦¬)
14. [ë¬¸ì œ í•´ê²°](#ë¬¸ì œ-í•´ê²°)

## ê°œìš”

Girls Band Tabi í”„ë¡œì íŠ¸ëŠ” ìœ„ì¹˜ ê¸°ë°˜ ì„±ì§€ìˆœë¡€(pilgrimage) ì• í”Œë¦¬ì¼€ì´ì…˜ì„ ê´€ë¦¬í•˜ê¸° ìœ„í•´ PostGIS í™•ì¥(extension)ì´ í¬í•¨ëœ PostgreSQL ë°ì´í„°ë² ì´ìŠ¤ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤. ì´ ì‹œìŠ¤í…œì€ ì—¬ëŸ¬ ê±¸ê·¸ë£¹ í”„ë¡œì íŠ¸, ì§€ë¦¬ì  ìœ„ì¹˜ ì¶”ì , ì‚¬ìš©ì ìƒì„± ì½˜í…ì¸ (UGC), ë¼ì´ë¸Œ ì´ë²¤íŠ¸ ê´€ë¦¬ë¥¼ ì§€ì›í•©ë‹ˆë‹¤.

### í•µì‹¬ ê¸°ëŠ¥ (Core Features)
- **ë‹¤ì¤‘ í”„ë¡œì íŠ¸ ì§€ì› (Multi-Project Support)**: ë‹¨ì¼ ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ì—¬ëŸ¬ ê±¸ê·¸ë£¹ í”„ë¡œì íŠ¸ ê´€ë¦¬
- **ì§€ë¦¬ê³µê°„ ê¸°ëŠ¥ (Geospatial Features)**: ì •ë°€í•œ ìœ„ì¹˜ ì¶”ì  ë° ê·¼ì ‘ì„±(proximity) ê³„ì‚°ì„ ìœ„í•œ PostGIS
- **ì‚¬ìš©ì ìƒì„± ì½˜í…ì¸  (User-Generated Content)**: ëŒ“ê¸€, ì‚¬ì§„, ë°©ë¬¸ ê¸°ë¡ ì¶”ì 
- **ë¼ì´ë¸Œ ì´ë²¤íŠ¸ (Live Events)**: ì½˜ì„œíŠ¸ ì¥ì†Œ ë° ì°¸ì„ì ì¶”ì 
- **ë¯¸ë””ì–´ ê´€ë¦¬ (Media Management)**: ì´ë¯¸ì§€ ì—…ë¡œë“œ ë° ë©”íƒ€ë°ì´í„°(metadata) ì €ì¥
- **ê°ì‚¬ ì¶”ì  (Audit Trail)**: í¬ê´„ì ì¸ ë¡œê¹…(logging) ë° ê°ì‚¬ ì‹œìŠ¤í…œ

### ê¸°ìˆ  ìŠ¤íƒ (Technology Stack)
- **ë°ì´í„°ë² ì´ìŠ¤ (Database)**: PostgreSQL 15 with PostGIS 3.3
- **ORM**: ìµœì í™”ëœ JPA/Hibernate
- **ì»¤ë„¥ì…˜ í’€ (Connection Pool)**: HikariCP
- **ë§ˆì´ê·¸ë ˆì´ì…˜ (Migration)**: Flyway
- **ìºì‹± (Caching)**: Redis + Caffeine
- **ê³µê°„ ë¼ì´ë¸ŒëŸ¬ë¦¬ (Spatial Library)**: JTS (Java Topology Suite)

## ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ ì•„í‚¤í…ì²˜

### í•µì‹¬ ë„ë©”ì¸ ëª¨ë¸

ë°ì´í„°ë² ì´ìŠ¤ëŠ” ë‹¤ìŒ ì£¼ìš” ë„ë©”ì¸ì„ ì¤‘ì‹¬ìœ¼ë¡œ êµ¬ì„±ë©ë‹ˆë‹¤:

```
â”œâ”€â”€ ì‹ ì› ë° ë³´ì•ˆ (Identity & Security)
â”‚   â”œâ”€â”€ users (ì¸ì¦ ë° í”„ë¡œí•„)
â”‚   â”œâ”€â”€ subject_map (OAuth ì£¼ì²´ ë§¤í•‘)
â”‚   â”œâ”€â”€ email_verification_tokens (ì´ë©”ì¼ ì¸ì¦)
â”‚   â””â”€â”€ audit_log (ë³´ì•ˆ ê°ì‚¬ ì¶”ì )
â”‚
â”œâ”€â”€ í”„ë¡œì íŠ¸ ë° ì½˜í…ì¸  (Projects & Content)
â”‚   â”œâ”€â”€ projects (ê±¸ê·¸ë£¹ í”„ë¡œì íŠ¸)
â”‚   â”œâ”€â”€ units (í”„ë¡œì íŠ¸ ë‚´ ë°´ë“œ/ê·¸ë£¹)
â”‚   â”œâ”€â”€ unit_members (ê°œë³„ ë©¤ë²„/ìºë¦­í„°)
â”‚   â”œâ”€â”€ voice_actors (ì„±ìš° ì •ë³´)
â”‚   â””â”€â”€ member_voice_actors (ìºë¦­í„°-ì„±ìš° ê´€ê³„)
â”‚
â”œâ”€â”€ ì§€ë¦¬ì  ë°ì´í„° (Geographical Data)
â”‚   â”œâ”€â”€ regions (ê³„ì¸µì  ìœ„ì¹˜ ë°ì´í„°)
â”‚   â”œâ”€â”€ places (PostGIS ì§€ì˜¤ë©”íŠ¸ë¦¬ë¥¼ í¬í•¨í•œ ë¬¼ë¦¬ì  ìœ„ì¹˜)
â”‚   â”œâ”€â”€ place_units (ì¥ì†Œ-ë°´ë“œ ì—°ê´€)
â”‚   â”œâ”€â”€ place_images (ìœ„ì¹˜ ì‚¬ì§„)
â”‚   â”œâ”€â”€ place_guides (ì‚¬ìš©ì ìƒì„± ê°€ì´ë“œ)
â”‚   â””â”€â”€ place_comments (ì‚¬ìš©ì ëŒ“ê¸€ ë° ë¦¬ë·°)
â”‚
â”œâ”€â”€ ì´ë²¤íŠ¸ ë° ë°©ë¬¸ (Events & Visits)
â”‚   â”œâ”€â”€ live_events (ì½˜ì„œíŠ¸ ë° ê³µì—°)
â”‚   â”œâ”€â”€ live_attendances (ì‚¬ìš©ì ì°¸ì„ ê¸°ë¡)
â”‚   â”œâ”€â”€ visit_events (ìœ„ì¹˜ ì²´í¬ì¸)
â”‚   â””â”€â”€ visit_summary (ì§‘ê³„ëœ ë°©ë¬¸ í†µê³„)
â”‚
â”œâ”€â”€ ë¯¸ë””ì–´ ë° ì½˜í…ì¸  (Media & Content)
â”‚   â”œâ”€â”€ uploads (íŒŒì¼ ë©”íƒ€ë°ì´í„° ë° ì €ì¥ì†Œ ì°¸ì¡°)
â”‚   â”œâ”€â”€ media_catalogs (ë¯¸ë””ì–´ ì½˜í…ì¸  ì¹´íƒˆë¡œê·¸)
â”‚   â”œâ”€â”€ media_entries (ê°œë³„ ì—í”¼ì†Œë“œ/ì±•í„°)
â”‚   â”œâ”€â”€ news_items (ë‰´ìŠ¤ ë° ê³µì§€ì‚¬í•­)
â”‚   â””â”€â”€ media_delete_requests (ì½˜í…ì¸  ì¡°ì •)
â”‚
â””â”€â”€ ì»¤ë®¤ë‹ˆí‹° ê¸°ëŠ¥ (Community Features)
    â”œâ”€â”€ posts (ì‚¬ìš©ì ìƒì„± ê²Œì‹œë¬¼)
    â”œâ”€â”€ comments (ê²Œì‹œë¬¼ ëŒ“ê¸€)
    â”œâ”€â”€ favorites (ì‚¬ìš©ì ë¶ë§ˆí¬)
    â”œâ”€â”€ notifications (ì‚¬ìš©ì ì•Œë¦¼)
    â””â”€â”€ notification_settings (ì•Œë¦¼ ì„¤ì •)
```

### ë°ì´í„°ë² ì´ìŠ¤ ì„¤ê³„ ì›ì¹™ (Database Design Principles)

1. **ì• í”Œë¦¬ì¼€ì´ì…˜ ê´€ë¦¬ ê´€ê³„ (Application-Managed Relationships)**: ì—°ì‡„ ë¬¸ì œ(cascade issues)ë¥¼ í”¼í•˜ê¸° ìœ„í•œ ìµœì†Œí•œì˜ ì™¸ë˜í‚¤ ì œì•½(foreign key constraints)
2. **ë¹ ë¥¸ í•„í„°ë§ì„ ìœ„í•œ ë°°ì—´ ì»¬ëŸ¼ (Array Columns for Fast Filtering)**: ì„±ëŠ¥ì„ ìœ„í•œ GIN ì¸ë±ìŠ¤ê°€ ìˆëŠ” PostgreSQL ë°°ì—´
3. **ì†Œí”„íŠ¸ ì‚­ì œ (Soft Delete)**: í•˜ë“œ ì‚­ì œ ëŒ€ì‹  `is_active` í”Œë˜ê·¸ ì‚¬ìš©
4. **ë‚™ê´€ì  ì ê¸ˆ (Optimistic Locking)**: ë™ì‹œ ì ‘ê·¼ ì œì–´ë¥¼ ìœ„í•œ ë²„ì „ í•„ë“œ
5. **ê°ì‚¬ ì¶”ì  (Audit Trail)**: ë³´ì•ˆ ë° ë””ë²„ê¹…ì„ ìœ„í•œ í¬ê´„ì  ë¡œê¹…
6. **ê³µê°„ ì¸ë±ì‹± (Spatial Indexing)**: ì§€ë¦¬ì  ì¿¼ë¦¬(geographical queries)ë¥¼ ìœ„í•œ PostGIS GIST ì¸ë±ìŠ¤

### 2025-11-17 ìŠ¤í‚¤ë§ˆ ì—…ë°ì´íŠ¸ â€” `places.intro_text`
- `V002__create_core_tables.sql`ì— `intro_text TEXT` ì—´ì„ ì¶”ê°€í•´ ì¹´ë“œ/ê³µìœ ìš© ì§§ì€ ì†Œê°œ ë¬¸êµ¬ë¥¼ 1ê¸‰ ì†ì„±ìœ¼ë¡œ ìŠ¹ê²©í–ˆìŠµë‹ˆë‹¤.
- ë°ì´í„° ì‹œë”© ë§ˆì´ê·¸ë ˆì´ì…˜(`V033__add_places_data.sql`)ì€ `intro_text`ê°€ ë¹„ì–´ ìˆëŠ” í–‰ì„ `LEFT(description, 200)`ë¡œ ìë™ ì´ˆê¸°í™”í•˜ì—¬ ê³¼ê±° ë°ì´í„°ë„ ì¦‰ì‹œ UIì— ë…¸ì¶œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
- ì• í”Œë¦¬ì¼€ì´ì…˜ ê³„ì¸µì€ `Create/UpdatePlaceRequest`ì— `introText`ë¥¼ í—ˆìš©í•˜ë©°, ê°’ì´ ì—†ìœ¼ë©´ `description` ì•ë¶€ë¶„ì„ ì˜ë¼ ìë™ ë³´ì •í•©ë‹ˆë‹¤.

```sql
ALTER TABLE places
    ADD COLUMN IF NOT EXISTS intro_text TEXT;

UPDATE places
SET intro_text = LEFT(description, 200)
WHERE intro_text IS NULL
  AND description IS NOT NULL;
```

## PostgreSQL + PostGIS ì„¤ì • (PostgreSQL + PostGIS Setup)

### í•„ìˆ˜ í™•ì¥ (Required Extensions)

```sql
-- Core PostgreSQL extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

-- PostGIS for geospatial features
CREATE EXTENSION IF NOT EXISTS postgis;
CREATE EXTENSION IF NOT EXISTS postgis_topology;
CREATE EXTENSION IF NOT EXISTS btree_gist;
```

### Docker ì„¤ì • (Docker Configuration)

í”„ë¡œì íŠ¸ëŠ” ê°œë°œì„ ìœ„í•´ PostGIS Docker ì´ë¯¸ì§€ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤:

```yaml
# docker-compose.yml
database:
  image: postgis/postgis:15-3.3
  platform: "linux/amd64"
  environment:
    POSTGRES_DB: girlsbandtabi
    POSTGRES_USER: girlsbandtabi
    POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
  volumes:
    - ./docker-data/postgres:/var/lib/postgresql/data
```

### ì—°ê²° ì„¤ì • (Connection Configuration)

```yaml
# application.yml
spring:
  datasource:
    url: jdbc:postgresql://localhost:5432/girlsbandtabi
    username: ${DB_USERNAME:girlsbandtabi}
    password: ${DB_PASSWORD:girlsbandtabi}
    driver-class-name: org.postgresql.Driver
    hikari:
      auto-commit: false
      maximum-pool-size: 20
      minimum-idle: 5
      connection-timeout: 30000
      idle-timeout: 600000
      max-lifetime: 1800000
```

## ì—”í‹°í‹° ê´€ê³„ (Entity Relationships)

### í•µì‹¬ ì—”í‹°í‹° ê´€ê³„ (Core Entity Relationships)

![ì£¼ìš” ì—”í‹°í‹° ê´€ê³„ ë‹¤ì´ì–´ê·¸ë¨ (Primary Entity Relationship Diagram)](./images/ë°ì´í„°ë² ì´ìŠ¤ì„¤ê³„_v2025.11.17_diagram_1.svg)

<details>
<summary>Mermaid ì›ë³¸ ì½”ë“œ ë³´ê¸°</summary>

```mermaid
erDiagram
    users ||--o{ subject_map : "has"
    users ||--o{ visit_events : "creates"
    users ||--o{ favorites : "bookmarks"
    
    projects ||--o{ units : "contains"
    projects ||--o{ places : "has_locations"
    projects ||--o{ live_events : "hosts"
    
    units ||--o{ unit_members : "contains"
    unit_members ||--o{ member_voice_actors : "voiced_by"
    voice_actors ||--o{ member_voice_actors : "voices"
    
    regions ||--o{ regions : "parent_child"
    regions ||--o{ places : "contains"
    places ||--o{ place_units : "associated_with"
    places ||--o{ place_images : "has"
    places ||--o{ place_comments : "receives"
    places ||--o{ visit_events : "location_of"
    
    live_events ||--o{ live_attendances : "attended_by"
    live_events ||--o{ live_event_units : "features"
    
    uploads ||--o{ place_images : "stores"
    uploads ||--o{ news_images : "stores"
```

<!-- ë°ì´í„°ë² ì´ìŠ¤ ERD (Entity Relationship Diagram) -->
![ë°ì´í„°ë² ì´ìŠ¤ ERD (Entity Relationship Diagram)](./images/ë°ì´í„°ë² ì´ìŠ¤ì„¤ê³„_v2025.11.17_diagram_1.svg)


</details>

### ì£¼ìš” ê´€ê³„ íŒ¨í„´ (Key Relationship Patterns)

#### 1. ì—°ê²° í…Œì´ë¸”ì„ ì‚¬ìš©í•œ ë‹¤ëŒ€ë‹¤ ê´€ê³„ (Many-to-Many with Junction Tables)
```sql
-- Place-Unit associations
CREATE TABLE place_units (
    place_id UUID NOT NULL,
    unit_id UUID NOT NULL,
    PRIMARY KEY (place_id, unit_id)
);
```

#### 2. ë°°ì—´ ê¸°ë°˜ ë¹ ë¥¸ ì¡°íšŒ (Array-Based Fast Lookups)
```sql
-- Places with denormalized arrays for fast filtering
CREATE TABLE places (
    id UUID PRIMARY KEY,
    project_ids UUID[] NOT NULL DEFAULT ARRAY[]::UUID[],
    unit_ids UUID[] NOT NULL DEFAULT ARRAY[]::UUID[],
    character_ids UUID[] NOT NULL DEFAULT ARRAY[]::UUID[],
    intro_text TEXT,
    -- ... other columns
);

-- GIN indexes for array operations
CREATE INDEX idx_places_project_ids_gin ON places USING GIN (project_ids);
CREATE INDEX idx_places_unit_ids_gin ON places USING GIN (unit_ids);
```

#### 3. ê³„ì¸µì  ë°ì´í„° - ì§€ì—­ (Hierarchical Data - Regions)
```sql
-- Self-referencing hierarchy
CREATE TABLE regions (
    region_code VARCHAR(32) PRIMARY KEY,
    parent_code VARCHAR(32), -- Self-reference
    region_type VARCHAR(20) NOT NULL,
    level SMALLINT NOT NULL,
    -- ... other columns
);
```

## ê³µê°„ ë°ì´í„° ì„¤ê³„ íŒ¨í„´ (Spatial Data Design Patterns)

### ì§€ë¦¬ ì¢Œí‘œê³„ (Geographic Coordinate System)

ì‹œìŠ¤í…œì€ ëª¨ë“  ê³µê°„ ë°ì´í„°ì— **EPSG:4326 (WGS84)**ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤:

```sql
-- PostGIS Point geometry with WGS84
location geography(Point, 4326) NOT NULL
```

### ê³µê°„ ë°ì´í„° ì €ì¥ (Spatial Data Storage)

#### Places í…Œì´ë¸” ê³µê°„ ì„¤ê³„ (Places Table Spatial Design)
```sql
CREATE TABLE places (
    id UUID PRIMARY KEY,
    location geography(Point, 4326) NOT NULL,
    verification_radius_m INT NOT NULL DEFAULT 10,
    address TEXT,
    region_code VARCHAR(32)
);

-- Spatial index for efficient proximity queries
CREATE INDEX idx_places_location_gist ON places USING GIST (location);
```

### ê³µê°„ ì¿¼ë¦¬ íŒ¨í„´ (Spatial Query Patterns)

#### 1. ê·¼ì ‘ì„± ê²€ìƒ‰ (Proximity Search)
```sql
-- Find places within 100 meters of a point
SELECT p.*
FROM places p
WHERE ST_DWithin(
    p.location::geometry,
    ST_GeomFromText('POINT(139.7005 35.6617)', 4326),
    100  -- meters
)
AND p.is_active = true;
```

#### 2. ìœ„ì¹˜ ê²€ì¦ (Location Verification)
```sql
-- Check if user location is within place verification radius
SELECT COUNT(*) > 0 as is_within_radius
FROM places p
WHERE p.id = $1
AND ST_DWithin(
    p.location::geometry,
    ST_GeomFromText('POINT($2 $3)', 4326),
    p.verification_radius_m
);
```

#### 3. ì§€ì—­ ì¿¼ë¦¬ (Regional Queries)
```sql
-- Places within a region (using bounding box)
SELECT p.*
FROM places p
JOIN regions r ON p.region_code = r.region_code
WHERE r.country_code = 'JPN'
AND p.is_active = true;
```

### ê³µê°„ ì¿¼ë¦¬ ì„±ëŠ¥ ìµœì í™” (Spatial Query Performance Optimization)

1. **ì ì ˆí•œ ì¸ë±ìŠ¤ ì‚¬ìš© (Proper Index Usage)**:
   ```sql
   CREATE INDEX idx_places_location_gist ON places USING GIST (location);
   CREATE INDEX idx_places_location_active ON places USING GIST (location) 
   WHERE is_active = true;
   ```

2. **ê±°ë¦¬ ê³„ì‚°ì„ ìœ„í•´ geographyë¥¼ geometryë¡œ ë³€í™˜ (Convert geography to geometry for distance calculations)**:
   ```sql
   -- More efficient for short distances
   ST_DWithin(location::geometry, target::geometry, distance)
   ```

3. **ëŒ€ê·œëª¨ ì§€ì—­ì— ëŒ€í•œ ê²½ê³„ ìƒì ì¿¼ë¦¬ ì‚¬ìš© (Use bounding box queries for large areas)**:
   ```sql
   WHERE location && ST_MakeEnvelope(min_lon, min_lat, max_lon, max_lat, 4326)
   ```

## ë§ˆì´ê·¸ë ˆì´ì…˜ ì „ëµ & Flyway (Migration Strategy & Flyway)

### Flyway ì„¤ì • (Flyway Configuration)

```yaml
# application.yml
flyway:
  enabled: true  # Environment-specific
  url: jdbc:postgresql://localhost:5432/girlsbandtabi
  user: ${DB_USERNAME:girlsbandtabi}
  password: ${DB_PASSWORD:girlsbandtabi}
  locations: classpath:db/migration
  baseline-on-migrate: true
  baseline-version: 000
  validate-on-migrate: false
  out-of-order: true
  mixed: true
  ignore-migration-patterns: "*:missing,*:ignored"
```

### ë§ˆì´ê·¸ë ˆì´ì…˜ ëª…ëª… ê·œì¹™ (Migration Naming Convention)

```
V{version}__{description}.sql

Examples:
V001__enable_extensions.sql
V002__create_core_tables.sql
V035__optimize_place_region_mapping.sql
V091__add_places_array_gin_indexes.sql
```

### ë§ˆì´ê·¸ë ˆì´ì…˜ ëª¨ë²” ì‚¬ë¡€ (Migration Best Practices)

#### 1. í™•ì¥ ê¸°ëŠ¥ ê´€ë¦¬ (Extension Management)
```sql
-- V001__enable_extensions.sql
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pgcrypto";
CREATE EXTENSION IF NOT EXISTS postgis;
```

#### 2. ì ì ˆí•œ ì¸ë±ì‹±ì„ í¬í•¨í•œ í…Œì´ë¸” ìƒì„± (Table Creation with Proper Indexing)
```sql
-- Create table with immediate indexes (ì¦‰ì‹œ ì¸ë±ìŠ¤ì™€ í•¨ê»˜ í…Œì´ë¸” ìƒì„±)
CREATE TABLE IF NOT EXISTS places (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    location geography(Point, 4326) NOT NULL,
    -- ... other columns
);

-- Add indexes immediately (ì¦‰ì‹œ ì¸ë±ìŠ¤ ì¶”ê°€)
CREATE INDEX IF NOT EXISTS idx_places_location_gist ON places USING GIST (location);
```

#### 3. ì•ˆì „í•œ ì»¬ëŸ¼ ì¶”ê°€ (Safe Column Addition)
```sql
-- Add column with default value (ê¸°ë³¸ê°’ê³¼ í•¨ê»˜ ì»¬ëŸ¼ ì¶”ê°€)
ALTER TABLE places ADD COLUMN IF NOT EXISTS verification_radius_m INT NOT NULL DEFAULT 10;

-- Update existing rows if needed (í•„ìš”ì‹œ ê¸°ì¡´ í–‰ ì—…ë°ì´íŠ¸)
UPDATE places SET verification_radius_m = 50 WHERE place_type = 'large_venue';
```

#### 4. ê²€ì¦ì„ í¬í•¨í•œ ë°ì´í„° ë§ˆì´ê·¸ë ˆì´ì…˜ (Data Migration with Validation)
```sql
-- Data transformation with error handling (ì˜¤ë¥˜ ì²˜ë¦¬ë¥¼ í¬í•¨í•œ ë°ì´í„° ë³€í™˜)
DO $$
DECLARE
    affected_count INTEGER;
BEGIN
    -- Perform update (ì—…ë°ì´íŠ¸ ìˆ˜í–‰)
    UPDATE places SET region_code = 'JPN-13-101' 
    WHERE ST_DWithin(location::geometry, ST_GeomFromText('POINT(139.7 35.66)', 4326), 0.1);
    
    GET DIAGNOSTICS affected_count = ROW_COUNT;
    RAISE NOTICE 'Updated % places in Shibuya region', affected_count;
    
    -- Validation (ê²€ì¦)
    IF affected_count = 0 THEN
        RAISE WARNING 'No places updated - check coordinates';
    END IF;
END $$;
```

### ë¡¤ë°± ì „ëµ (Rollback Strategy)

1. **ì¶”ê°€ì  ë³€ê²½ (Additive Changes)**: ì¼ë°˜ì ìœ¼ë¡œ ë¡¤ë°±ì´ ì•ˆì „í•¨
2. **íŒŒê´´ì  ë³€ê²½ (Destructive Changes)**: í•­ìƒ ë¨¼ì € ë°±ì—…
3. **ë°ì´í„° ë³€í™˜ (Data Transformation)**: ì—­ ë³€í™˜ í¬í•¨

```sql
-- Example rollback for column addition
-- Rollback V035: Remove new region mappings
UPDATE places SET region_code = NULL WHERE region_code LIKE 'JPN-%';
```

## ì¸ë±ì‹± ì „ëµ (Indexing Strategy)

### ì¸ë±ìŠ¤ ìœ í˜• ë° ì‚¬ìš©ë²• (Index Types and Usage)

#### 1. B-tree ì¸ë±ìŠ¤ - ê¸°ë³¸ê°’ (B-tree Index - Default)
```sql
-- Primary keys and unique constraints
CREATE UNIQUE INDEX idx_users_email ON users (email);

-- Query performance
CREATE INDEX idx_places_project_id ON places (project_id);
CREATE INDEX idx_places_created_at ON places (created_at);

-- Compound indexes for common query patterns
CREATE INDEX idx_places_project_active ON places (project_id, is_active) WHERE is_active;
```

#### 2. GIN ì¸ë±ìŠ¤ - ë°°ì—´ ë° JSON ë°ì´í„° (GIN Index - Array and JSON Data)
```sql
-- Array columns for fast contains operations
CREATE INDEX idx_places_project_ids_gin ON places USING GIN (project_ids);
CREATE INDEX idx_places_unit_ids_gin ON places USING GIN (unit_ids);

-- JSONB columns
CREATE INDEX idx_email_verification_metadata_gin ON email_verification_tokens USING GIN (metadata);
```

#### 3. GIST ì¸ë±ìŠ¤ - ê³µê°„ ë°ì´í„° (GIST Index - Spatial Data)
```sql
-- PostGIS spatial indexes
CREATE INDEX idx_places_location_gist ON places USING GIST (location);
CREATE INDEX idx_visit_events_location_gist ON visit_events USING GIST (location);

-- Partial spatial indexes for active records
CREATE INDEX idx_places_location_active_gist ON places USING GIST (location) 
WHERE is_active = true;
```

#### 4. ë¶€ë¶„ ì¸ë±ìŠ¤ (Partial Indexes)
```sql
-- Index only active records
CREATE INDEX idx_places_active ON places (is_active) WHERE is_active;

-- Index only published content
CREATE INDEX idx_news_items_published_time ON news_items (published_at DESC) 
WHERE is_published;
```

#### 5. í‘œí˜„ì‹ ì¸ë±ìŠ¤ (Expression Indexes)
```sql
-- Index on computed values
CREATE INDEX idx_places_location_text ON places (lower(address)) 
WHERE address IS NOT NULL;
```

### ì¸ë±ìŠ¤ ëª¨ë‹ˆí„°ë§ (Index Monitoring)

#### 1. ì¸ë±ìŠ¤ ì‚¬ìš©ëŸ‰ í™•ì¸ (Check Index Usage)
```sql
-- Find unused indexes
SELECT schemaname, tablename, indexname, idx_tup_read, idx_tup_fetch
FROM pg_stat_user_indexes 
WHERE idx_tup_read = 0 AND idx_tup_fetch = 0;
```

#### 2. ì¸ë±ìŠ¤ íš¨ê³¼ì„± ë¶„ì„ (Index Effectiveness Analysis)
```sql
-- Check index bloat
SELECT schemaname, tablename, indexname,
       pg_size_pretty(pg_relation_size(indexrelid)) as index_size,
       idx_tup_read, idx_tup_fetch
FROM pg_stat_user_indexes 
ORDER BY pg_relation_size(indexrelid) DESC;
```

#### 3. ì¿¼ë¦¬ ì„±ëŠ¥ ë¶„ì„ (Query Performance Analysis)
```sql
-- Enable query planning analysis
EXPLAIN (ANALYZE, BUFFERS) 
SELECT * FROM places 
WHERE ST_DWithin(location::geometry, ST_GeomFromText('POINT(139.7 35.66)', 4326), 100)
AND project_ids @> ARRAY['550e8400-e29b-41d4-a716-446655440000'::uuid];
```

## ì„±ëŠ¥ ê³ ë ¤ì‚¬í•­

### ì¿¼ë¦¬ ìµœì í™” ì „ëµ

#### 1. Hibernate/JPA ìµœì í™”
```kotlin
// JpaOptimizationConfig.kt
hibernateProperties["hibernate.jdbc.batch_size"] = "25"
hibernateProperties["hibernate.order_inserts"] = "true"
hibernateProperties["hibernate.order_updates"] = "true"
hibernateProperties["hibernate.jdbc.batch_versioned_data"] = "true"
```

#### 2. ì»¤ë„¥ì…˜ í’€ íŠœë‹
```yaml
# HikariCP configuration
spring:
  datasource:
    hikari:
      auto-commit: false
      maximum-pool-size: 20        # Based on CPU cores * 2
      minimum-idle: 5              # Always maintain connections
      connection-timeout: 30000    # 30 seconds
      idle-timeout: 600000         # 10 minutes
      max-lifetime: 1800000        # 30 minutes
      leak-detection-threshold: 60000  # 1 minute
```

#### 3. N+1 ì¿¼ë¦¬ ë°©ì§€
```kotlin
// Use fetch joins in repository methods
@Query("""
    SELECT p FROM PlaceEntity p
    LEFT JOIN FETCH p.images
    LEFT JOIN FETCH p.placeUnits
    WHERE p.isActive = true
""")
fun findActiveWithDetails(): List<PlaceEntity>
```

#### 4. ì• í”Œë¦¬ì¼€ì´ì…˜ ë ˆë²¨ ìµœì í™”

**ë°°ì—´ ê¸°ë°˜ í•„í„°ë§**:
```sql
-- Fast array containment queries
SELECT * FROM places 
WHERE project_ids @> ARRAY[?::uuid] 
AND is_active = true;
```

**ë°°ì¹˜ ì‘ì—…**:
```kotlin
// Batch insert example
@Transactional
fun batchInsertPlaces(places: List<PlaceEntity>) {
    places.chunked(25).forEach { chunk ->
        placeRepository.saveAll(chunk)
        entityManager.flush()
        entityManager.clear()
    }
}
```

### ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§

#### 1. ë°ì´í„°ë² ì´ìŠ¤ í†µê³„
```sql
-- Query performance statistics
SELECT query, calls, total_time, mean_time, rows
FROM pg_stat_statements 
ORDER BY total_time DESC 
LIMIT 10;
```

#### 2. ì¸ë±ìŠ¤ ì‚¬ìš© ëª¨ë‹ˆí„°ë§
```sql
-- Monitor index hit ratio
SELECT 
    schemaname,
    tablename,
    indexrelname,
    idx_tup_read,
    idx_tup_fetch,
    idx_tup_read + idx_tup_fetch as total_reads
FROM pg_stat_user_indexes 
ORDER BY total_reads DESC;
```

#### 3. ì»¤ë„¥ì…˜ í’€ ì§€í‘œ
- í™œì„± ì—°ê²° ëª¨ë‹ˆí„°ë§
- ì—°ê²° íšë“ ì‹œê°„ ì¶”ì 
- ì—°ê²° ëˆ„ìˆ˜ ê°ì‹œ

### ì„±ëŠ¥ ë²¤ì¹˜ë§ˆí¬

ëª©í‘œ ì„±ëŠ¥ ì§€í‘œ:
- **ì¿¼ë¦¬ ì‘ë‹µ ì‹œê°„**: 95%ì˜ ì¿¼ë¦¬ì—ì„œ < 100ms
- **ê³µê°„ ì¿¼ë¦¬**: 1km ë‚´ ê·¼ì ‘ì„± ê²€ìƒ‰ì—ì„œ < 200ms
- **ì¸ë±ìŠ¤ ì‚¬ìš©**: ë¹ˆë²ˆíˆ ì ‘ê·¼í•˜ëŠ” í…Œì´ë¸”ì—ì„œ > 95%
- **ì»¤ë„¥ì…˜ í’€**: < 50ms ì—°ê²° íšë“ ì‹œê°„
- **ìºì‹œ íˆíŠ¸ ë¹„ìœ¨**: ë°˜ë³µ ì¿¼ë¦¬ì—ì„œ > 90%

## ì¿¼ë¦¬ ìµœì í™”

### ì¼ë°˜ì ì¸ ì¿¼ë¦¬ íŒ¨í„´

#### 1. ê³µê°„ ê·¼ì ‘ì„± ì¿¼ë¦¬
```sql
-- Optimized proximity search with index hints
SELECT p.id, p.name, p.address,
       ST_Distance(p.location::geometry, ST_GeomFromText('POINT(139.7 35.66)', 4326)) as distance_m
FROM places p
WHERE p.is_active = true
AND p.project_ids @> ARRAY[$1::uuid]
AND ST_DWithin(
    p.location::geometry,
    ST_GeomFromText('POINT(139.7 35.66)', 4326),
    1000  -- 1km radius
)
ORDER BY p.location::geometry <-> ST_GeomFromText('POINT(139.7 35.66)', 4326)
LIMIT 20;
```

#### 2. ê³„ì¸µì  ì§€ì—­ ì¿¼ë¦¬
```sql
-- Efficient region hierarchy traversal
WITH RECURSIVE region_hierarchy AS (
    -- Base case: find target region
    SELECT region_code, parent_code, name_ko, level, ARRAY[region_code] as path
    FROM regions 
    WHERE region_code = $1
    
    UNION ALL
    
    -- Recursive case: find all children
    SELECT r.region_code, r.parent_code, r.name_ko, r.level,
           rh.path || r.region_code
    FROM regions r
    JOIN region_hierarchy rh ON r.parent_code = rh.region_code
    WHERE r.is_active = true
)
SELECT p.*
FROM places p
JOIN region_hierarchy rh ON p.region_code = rh.region_code
WHERE p.is_active = true;
```

#### 3. ì§‘ê³„ëœ ë°©ë¬¸ í†µê³„
```sql
-- Optimized visit summary calculation
SELECT 
    p.id,
    p.name,
    COUNT(ve.id) as total_visits,
    COUNT(DISTINCT ve.subject_id) as unique_visitors,
    MIN(ve.created_at) as first_visit,
    MAX(ve.created_at) as last_visit
FROM places p
LEFT JOIN visit_events ve ON ve.place_id = p.id 
    AND ve.status = 'VERIFIED'
    AND ve.created_at > NOW() - INTERVAL '30 days'
WHERE p.is_active = true
    AND p.project_ids @> ARRAY[$1::uuid]
GROUP BY p.id, p.name
HAVING COUNT(ve.id) > 0
ORDER BY total_visits DESC
LIMIT 50;
```

### ì‹¤í–‰ ê³„íš ë¶„ì„

#### 1. ì¿¼ë¦¬ ë¶„ì„ í™œì„±í™”
```sql
-- Analyze query execution
EXPLAIN (ANALYZE, BUFFERS, FORMAT JSON) 
SELECT /* your query here */;
```

#### 2. ì¼ë°˜ì ì¸ ì„±ëŠ¥ ë¬¸ì œ

**ìˆœì°¨ ìŠ¤ìº” íƒì§€**:
```sql
-- Look for Seq Scan in execution plan
EXPLAIN SELECT * FROM places WHERE name ILIKE '%tokyo%';

-- Solution: Add index
CREATE INDEX idx_places_name_trgm ON places USING GIN (name gin_trgm_ops);
```

**ë¹„íš¨ìœ¨ì ì¸ ì¡°ì¸**:
```sql
-- Check for nested loop joins on large tables
EXPLAIN ANALYZE
SELECT p.*, u.name as unit_name
FROM places p
JOIN place_units pu ON pu.place_id = p.id
JOIN units u ON u.id = pu.unit_id;
```

#### 3. ì¿¼ë¦¬ ìµœì í™” ë„êµ¬

**pg_stat_statements**:
```sql
-- Enable query statistics
CREATE EXTENSION pg_stat_statements;

-- Find slow queries
SELECT query, calls, total_time, mean_time
FROM pg_stat_statements
WHERE mean_time > 100  -- queries taking > 100ms
ORDER BY mean_time DESC;
```

## ë°ì´í„° ì‹œë”© & í…ŒìŠ¤íŠ¸ ë°ì´í„°

### ë§ˆì´ê·¸ë ˆì´ì…˜ ê¸°ë°˜ ì‹œë”©

#### 1. ì°¸ì¡° ë°ì´í„°
```sql
-- V034__add_regions_data.sql
INSERT INTO regions (region_code, parent_code, region_type, country_code, level, name_ko, name_en)
VALUES 
('JPN', NULL, 'COUNTRY', 'JPN', 0, 'ì¼ë³¸', 'Japan'),
('JPN-13', 'JPN', 'PREFECTURE', 'JPN', 1, 'ë„ì¿„ë„', 'Tokyo'),
('JPN-13-101', 'JPN-13', 'WARD', 'JPN', 2, 'ì‹œë¶€ì•¼êµ¬', 'Shibuya Ward');
```

#### 2. í…ŒìŠ¤íŠ¸ ë°ì´í„° ìƒì„±
```sql
-- V090__seed_additional_dummy_data.sql
-- Generate test places with realistic coordinates
INSERT INTO places (id, project_id, name, location, address, is_active, created_at, updated_at)
SELECT 
    gen_random_uuid(),
    '550e8400-e29b-41d4-a716-446655440000'::uuid,
    'Test Place ' || i,
    ST_GeogFromText('POINT(' || 
        (139.6 + random() * 0.2)::text || ' ' ||  -- Tokyo area longitude
        (35.6 + random() * 0.1)::text || ')'),     -- Tokyo area latitude
    'Test Address ' || i,
    true,
    NOW(),
    NOW()
FROM generate_series(1, 1000) as i;
```

### ê°œë°œ ë°ì´í„° ì „ëµ

#### 1. í”„ë¡œí•„ ê¸°ë°˜ ë°ì´í„° ë¡œë”©
```yaml
# application-test.yml
spring:
  flyway:
    locations: 
      - classpath:db/migration
      - classpath:db/test-data  # Additional test data
```

#### 2. ë°ì´í„° ë¦¬ì…‹ ìŠ¤í¬ë¦½íŠ¸
```sql
-- reset-test-data.sql
TRUNCATE TABLE visit_events, place_comments, live_attendances CASCADE;
-- Reset sequences
SELECT setval('audit_log_seq', 1, false);
```

### ë°ì´í„° ìƒì„± ë„êµ¬

#### 1. ê³µê°„ í…ŒìŠ¤íŠ¸ ë°ì´í„°
```kotlin
// Kotlin data generation helper
fun generateTestPlaces(count: Int): List<PlaceEntity> {
    val tokyoBounds = BoundingBox(
        minLat = 35.6,
        maxLat = 35.7,
        minLon = 139.6,
        maxLon = 139.8
    )
    
    return (1..count).map { i ->
        PlaceEntity(
            name = "Test Place $i",
            location = randomPointInBounds(tokyoBounds),
            projectId = TEST_PROJECT_ID,
            verificationRadiusM = Random.nextInt(10, 100)
        )
    }
}
```

#### 2. í˜„ì‹¤ì ì¸ ì‚¬ìš©ì í–‰ë™
```kotlin
// Generate realistic visit patterns
fun generateVisitEvents(places: List<PlaceEntity>, userCount: Int) {
    val users = generateTestUsers(userCount)
    
    users.forEach { user ->
        val visitsPerUser = Random.nextInt(5, 20)
        val userPlaces = places.shuffled().take(visitsPerUser)
        
        userPlaces.forEachIndexed { index, place ->
            val visitTime = baseTime.plusDays(index.toLong())
            createVisitEvent(user, place, visitTime)
        }
    }
}
```

## ì»¤ë„¥ì…˜ í’€ë§ (HikariCP)

### ì„¤ì • ëª¨ë²” ì‚¬ë¡€

#### 1. í’€ í¬ê¸° ê³„ì‚°
```yaml
# application.yml
spring:
  datasource:
    hikari:
      # CPU cores * 2 for typical web applications
      maximum-pool-size: ${DB_MAX_CONNECTIONS:20}
      
      # Keep some connections warm
      minimum-idle: ${DB_MIN_CONNECTIONS:5}
      
      # Connection acquisition timeout
      connection-timeout: 30000  # 30 seconds
      
      # How long connection can be idle
      idle-timeout: 600000       # 10 minutes
      
      # Maximum lifetime of connection
      max-lifetime: 1800000      # 30 minutes
      
      # Detect connection leaks
      leak-detection-threshold: 60000  # 1 minute
```

#### 2. ì„±ëŠ¥ íŠœë‹
```yaml
spring:
  datasource:
    hikari:
      # Disable autocommit for better performance
      auto-commit: false
      
      # Use server-side prepared statements
      cache-prep-stmts: true
      prep-stmt-cache-size: 250
      prep-stmt-cache-sql-limit: 2048
      
      # MySQL-specific optimizations (if used)
      use-server-prep-stmts: true
      use-local-session-state: true
      rewrite-batched-statements: true
      
      # Health check query
      connection-test-query: "SELECT 1"
```

### ì»¤ë„¥ì…˜ í’€ ëª¨ë‹ˆí„°ë§

#### 1. JMX ì§€í‘œ
```kotlin
// Monitor HikariCP metrics
@Component
class ConnectionPoolMonitor {
    
    @EventListener
    fun onApplicationReady() {
        val mBeanServer = ManagementFactory.getPlatformMBeanServer()
        val poolName = ObjectName("com.zaxxer.hikari:type=Pool (HikariPool-1)")
        
        // Monitor active connections
        val activeConnections = mBeanServer.getAttribute(poolName, "ActiveConnections")
        
        // Monitor total connections
        val totalConnections = mBeanServer.getAttribute(poolName, "TotalConnections")
        
        logger.info("Active: $activeConnections, Total: $totalConnections")
    }
}
```

#### 2. ìƒíƒœ ê²€ì‚¬
```kotlin
// Custom health indicator
@Component
class DatabaseHealthIndicator : HealthIndicator {
    
    @Autowired
    private lateinit var dataSource: HikariDataSource
    
    override fun health(): Health {
        val pool = dataSource.hikariPoolMXBean
        
        val activeConnections = pool.activeConnections
        val totalConnections = pool.totalConnections
        val maxConnections = dataSource.maximumPoolSize
        
        val utilization = (activeConnections.toDouble() / maxConnections) * 100
        
        return when {
            utilization > 90 -> Health.down()
                .withDetail("utilization", "${utilization}%")
                .withDetail("active", activeConnections)
                .withDetail("total", totalConnections)
                .build()
            
            utilization > 75 -> Health.status("WARNING")
                .withDetail("utilization", "${utilization}%")
                .build()
                
            else -> Health.up()
                .withDetail("utilization", "${utilization}%")
                .build()
        }
    }
}
```

### ì»¤ë„¥ì…˜ í’€ ëª¨ë²” ì‚¬ë¡€

#### 1. í¬ê¸° ì¡°ì • ê°€ì´ë“œë¼ì¸
- **ìµœëŒ€ í’€ í¬ê¸°**: CPU ì½”ì–´ Ã— 2 (ì¼ë°˜ì ì¸ OLTP ì›Œí¬ë¡œë“œì˜ ê²½ìš°)
- **ìµœì†Œ ìœ íœ´**: ìµœëŒ€ í’€ í¬ê¸°ì˜ 25%
- **ì½ê¸° ì¤‘ì‹¬ ì›Œí¬ë¡œë“œ**: í’€ í¬ê¸° ì¦ê°€ ê°€ëŠ¥
- **ì“°ê¸° ì¤‘ì‹¬ ì›Œí¬ë¡œë“œ**: í’€ í¬ê¸°ë¥¼ ë³´ìˆ˜ì ìœ¼ë¡œ ìœ ì§€

#### 2. íƒ€ì„ì•„ì›ƒ ì„¤ì •
```yaml
spring:
  datasource:
    hikari:
      connection-timeout: 30000      # Time to get connection from pool
      validation-timeout: 5000       # Time to validate connection
      idle-timeout: 600000           # Time before idle connection is removed
      max-lifetime: 1800000          # Maximum time connection can live
```

#### 3. ì—°ê²° ìœ íš¨ì„± ê²€ì‚¬
```yaml
spring:
  datasource:
    hikari:
      connection-test-query: "SELECT 1"  # Simple validation query
      validation-timeout: 5000           # Quick validation
      
      # PostgreSQL-specific optimizations
      connection-init-sql: "SET TIME ZONE 'UTC'"
```

## ë°±ì—… & ìœ ì§€ë³´ìˆ˜

### ë°±ì—… ì „ëµ

#### 1. ë¬¼ë¦¬ì  ë°±ì—… (pg_basebackup)
```bash
#!/bin/bash
# Full backup script
BACKUP_DIR="/backups/postgresql"
TIMESTAMP=$(date +%Y%m%d_%H%M%S)

# Create base backup
pg_basebackup \
  -h localhost \
  -p 5432 \
  -U backup_user \
  -D "$BACKUP_DIR/base_$TIMESTAMP" \
  -Ft \
  -z \
  -P \
  -W

# Retain only last 7 days of backups
find "$BACKUP_DIR" -name "base_*" -type d -mtime +7 -exec rm -rf {} \;
```

#### 2. ë…¼ë¦¬ì  ë°±ì—… (pg_dump)
```bash
#!/bin/bash
# Schema and data backup
BACKUP_DIR="/backups/logical"
TIMESTAMP=$(date +%Y%m%d_%H%M%S)

# Full database dump
pg_dump \
  -h localhost \
  -p 5432 \
  -U girlsbandtabi \
  -d girlsbandtabi \
  --verbose \
  --format=custom \
  --compress=9 \
  --file="$BACKUP_DIR/girlsbandtabi_$TIMESTAMP.dump"

# Schema-only backup for development
pg_dump \
  -h localhost \
  -p 5432 \
  -U girlsbandtabi \
  -d girlsbandtabi \
  --schema-only \
  --file="$BACKUP_DIR/schema_$TIMESTAMP.sql"
```

#### 3. ì¦ë¶„ ë°±ì—… (WAL-E/WAL-G)
```yaml
# wal-g configuration
version: '3.8'
services:
  database:
    image: postgis/postgis:15-3.3
    environment:
      # Enable WAL archiving
      POSTGRES_INITDB_WALDIR: /var/lib/postgresql/wal
    volumes:
      - ./wal-config/postgresql.conf:/etc/postgresql/postgresql.conf
```

```bash
# postgresql.conf for WAL archiving
wal_level = replica
archive_mode = on
archive_command = 'wal-g wal-push %p'
max_wal_senders = 3
max_replication_slots = 3
```

### ìœ ì§€ë³´ìˆ˜ ì ˆì°¨

#### 1. ì •ê¸° ìœ ì§€ë³´ìˆ˜ ìŠ¤í¬ë¦½íŠ¸
```sql
-- Weekly maintenance script
-- Vacuum and analyze all tables
DO $$
DECLARE
    table_record RECORD;
BEGIN
    FOR table_record IN 
        SELECT schemaname, tablename 
        FROM pg_tables 
        WHERE schemaname = 'public'
    LOOP
        EXECUTE format('VACUUM ANALYZE %I.%I', 
                      table_record.schemaname, 
                      table_record.tablename);
        RAISE NOTICE 'Vacuumed table: %', table_record.tablename;
    END LOOP;
END $$;

-- Update table statistics
ANALYZE;

-- Check for bloated indexes
SELECT 
    schemaname,
    tablename,
    indexname,
    pg_size_pretty(pg_relation_size(indexrelid)) as size,
    pg_stat_user_indexes.idx_tup_read,
    pg_stat_user_indexes.idx_tup_fetch
FROM pg_stat_user_indexes
WHERE pg_relation_size(indexrelid) > 1024 * 1024  -- > 1MB
ORDER BY pg_relation_size(indexrelid) DESC;
```

#### 2. ì¸ë±ìŠ¤ ìœ ì§€ë³´ìˆ˜
```sql
-- Rebuild large indexes if needed
REINDEX INDEX CONCURRENTLY idx_places_location_gist;

-- Check index usage
SELECT 
    indexrelname,
    idx_tup_read,
    idx_tup_fetch,
    pg_size_pretty(pg_relation_size(indexrelid)) as size
FROM pg_stat_user_indexes 
WHERE schemaname = 'public'
ORDER BY pg_relation_size(indexrelid) DESC;
```

#### 3. ê³µê°„ ê´€ë¦¬
```sql
-- Check database size
SELECT pg_size_pretty(pg_database_size('girlsbandtabi'));

-- Check table sizes
SELECT 
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) as total_size,
    pg_size_pretty(pg_relation_size(schemaname||'.'||tablename)) as table_size,
    pg_size_pretty(pg_indexes_size(schemaname||'.'||tablename)) as index_size
FROM pg_tables
WHERE schemaname = 'public'
ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC;
```

### ëª¨ë‹ˆí„°ë§ ë° ì•Œë¦¼

#### 1. ë°ì´í„°ë² ì´ìŠ¤ ìƒíƒœ ê²€ì‚¬
```bash
#!/bin/bash
# Health check script
DB_NAME="girlsbandtabi"
ALERT_THRESHOLD=80

# Check connection count
CONN_COUNT=$(psql -d $DB_NAME -t -c "SELECT count(*) FROM pg_stat_activity;")
MAX_CONN=$(psql -d $DB_NAME -t -c "SHOW max_connections;")

CONN_PERCENT=$(( CONN_COUNT * 100 / MAX_CONN ))

if [ $CONN_PERCENT -gt $ALERT_THRESHOLD ]; then
    echo "ALERT: Connection usage at ${CONN_PERCENT}%"
    # Send notification
fi

# Check replication lag (if applicable)
LAG=$(psql -d $DB_NAME -t -c "SELECT EXTRACT(EPOCH FROM (now() - pg_last_xact_replay_timestamp()));")

if [ "${LAG%.*}" -gt 10 ]; then
    echo "ALERT: Replication lag: ${LAG} seconds"
fi
```

#### 2. ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§
```sql
-- Slow query monitoring
CREATE VIEW slow_queries AS
SELECT 
    query,
    calls,
    total_time,
    mean_time,
    (total_time/sum(total_time) OVER()) * 100 as percent_total
FROM pg_stat_statements 
WHERE mean_time > 100
ORDER BY mean_time DESC;
```

## ì¼ë°˜ì ì¸ ê³µê°„ ì¿¼ë¦¬

### ê±°ë¦¬ ë° ê·¼ì ‘ì„±

#### 1. ê·¼ì²˜ ì¥ì†Œ ì°¾ê¸°
```sql
-- Find places within walking distance (500m)
WITH nearby_places AS (
    SELECT 
        p.id,
        p.name,
        p.address,
        ST_Distance(p.location, ST_GeogFromText('POINT(139.7005 35.6617)')) as distance_m
    FROM places p
    WHERE p.is_active = true
    AND ST_DWithin(
        p.location,
        ST_GeogFromText('POINT(139.7005 35.6617)'),
        500  -- 500 meters
    )
)
SELECT * FROM nearby_places 
ORDER BY distance_m 
LIMIT 10;
```

#### 2. ê²€ì¦ í™•ì¸
```sql
-- Check if user location is within place verification radius
CREATE OR REPLACE FUNCTION check_location_verification(
    p_place_id UUID,
    p_user_lat DOUBLE PRECISION,
    p_user_lon DOUBLE PRECISION,
    p_user_accuracy DOUBLE PRECISION DEFAULT 50
) RETURNS BOOLEAN AS $$
DECLARE
    place_location GEOGRAPHY;
    verification_radius_m INT;
    distance_to_place DOUBLE PRECISION;
    effective_radius DOUBLE PRECISION;
BEGIN
    -- Get place location and verification radius
    SELECT location, verification_radius_m 
    INTO place_location, verification_radius_m
    FROM places 
    WHERE id = p_place_id AND is_active = true;
    
    IF place_location IS NULL THEN
        RETURN FALSE;
    END IF;
    
    -- Calculate distance
    SELECT ST_Distance(
        place_location,
        ST_GeogFromText('POINT(' || p_user_lon || ' ' || p_user_lat || ')')
    ) INTO distance_to_place;
    
    -- Add user accuracy to verification radius for buffer
    effective_radius := verification_radius_m + LEAST(p_user_accuracy, 100);
    
    RETURN distance_to_place <= effective_radius;
END;
$$ LANGUAGE plpgsql;

-- Usage
SELECT check_location_verification(
    '550e8400-e29b-41d4-a716-446655440000'::uuid,
    35.6617,   -- latitude
    139.7005,  -- longitude
    25         -- accuracy in meters
);
```

### ì§€ì—­ ì¿¼ë¦¬

#### 3. ì§€ì—­ ê³„ì¸µë³„ ì¥ì†Œ
```sql
-- Get all places in Tokyo (including sub-regions)
WITH tokyo_regions AS (
    WITH RECURSIVE region_tree AS (
        -- Root: Tokyo Prefecture
        SELECT region_code, parent_code, name_ko, level
        FROM regions 
        WHERE region_code = 'JPN-13'
        
        UNION ALL
        
        -- All descendants
        SELECT r.region_code, r.parent_code, r.name_ko, r.level
        FROM regions r
        JOIN region_tree rt ON r.parent_code = rt.region_code
        WHERE r.is_active = true
    )
    SELECT * FROM region_tree
)
SELECT 
    p.id,
    p.name,
    p.address,
    r.name_ko as region_name,
    COUNT(ve.id) as visit_count
FROM places p
JOIN tokyo_regions r ON p.region_code = r.region_code
LEFT JOIN visit_events ve ON ve.place_id = p.id 
    AND ve.created_at > NOW() - INTERVAL '30 days'
WHERE p.is_active = true
GROUP BY p.id, p.name, p.address, r.name_ko
ORDER BY visit_count DESC, p.name;
```

#### 4. ë°€ë„ ë¶„ì„
```sql
-- Find high-density areas (places per square km)
SELECT 
    r.name_ko as region_name,
    COUNT(p.id) as place_count,
    COUNT(p.id) / (
        -- Approximate area calculation for small regions
        ST_Area(ST_ConvexHull(ST_Collect(p.location::geometry))) / 1000000
    ) as places_per_sq_km
FROM regions r
JOIN places p ON p.region_code = r.region_code
WHERE r.level = 2  -- Ward/City level
    AND p.is_active = true
GROUP BY r.region_code, r.name_ko
HAVING COUNT(p.id) >= 5  -- At least 5 places
ORDER BY places_per_sq_km DESC;
```

### ê²½ë¡œ ë° ì—¬í–‰ ê³„íš

#### 5. ìµœì  ë°©ë¬¸ ê²½ë¡œ
```sql
-- Simple nearest neighbor route planning
WITH RECURSIVE route_planning AS (
    -- Start from a specific place
    SELECT 
        p.id,
        p.name,
        p.location,
        1 as visit_order,
        ARRAY[p.id] as visited_places
    FROM places p
    WHERE p.id = $1  -- Starting place ID
    
    UNION ALL
    
    -- Find nearest unvisited place
    SELECT 
        next_place.id,
        next_place.name,
        next_place.location,
        rp.visit_order + 1,
        rp.visited_places || next_place.id
    FROM route_planning rp
    CROSS JOIN LATERAL (
        SELECT p.id, p.name, p.location,
               ST_Distance(rp.location, p.location) as distance
        FROM places p
        WHERE p.is_active = true
            AND p.project_ids @> ARRAY[$2::uuid]  -- Specific project
            AND NOT (p.id = ANY(rp.visited_places))
        ORDER BY ST_Distance(rp.location, p.location)
        LIMIT 1
    ) as next_place
    WHERE rp.visit_order < 10  -- Max 10 places
        AND next_place.distance < 2000  -- Within 2km
)
SELECT 
    visit_order,
    name,
    ST_Y(location::geometry) as latitude,
    ST_X(location::geometry) as longitude
FROM route_planning
ORDER BY visit_order;
```

### ì§‘ê³„ ë° ë¶„ì„

#### 6. ë°©ë¬¸ íˆíŠ¸ë§µ ë°ì´í„°
```sql
-- Generate heatmap data for visualization
SELECT 
    ST_X(location::geometry) as longitude,
    ST_Y(location::geometry) as latitude,
    COUNT(ve.id) as visit_intensity,
    ARRAY_AGG(DISTINCT p.name) as place_names
FROM places p
LEFT JOIN visit_events ve ON ve.place_id = p.id
    AND ve.created_at > NOW() - INTERVAL '30 days'
    AND ve.status = 'VERIFIED'
WHERE p.is_active = true
    AND p.project_ids @> ARRAY[$1::uuid]
    -- Filter to specific geographic bounds
    AND ST_Within(
        p.location::geometry,
        ST_MakeEnvelope(139.6, 35.6, 139.8, 35.7, 4326)  -- Tokyo area
    )
GROUP BY p.location
HAVING COUNT(ve.id) > 0
ORDER BY visit_intensity DESC;
```

#### 7. ì‹œê°„ì  ê³µê°„ ë¶„ì„
```sql
-- Places with increasing popularity over time
WITH visit_trends AS (
    SELECT 
        p.id,
        p.name,
        p.location,
        DATE_TRUNC('week', ve.created_at) as visit_week,
        COUNT(ve.id) as weekly_visits
    FROM places p
    JOIN visit_events ve ON ve.place_id = p.id
    WHERE ve.created_at > NOW() - INTERVAL '12 weeks'
        AND ve.status = 'VERIFIED'
        AND p.is_active = true
    GROUP BY p.id, p.name, p.location, visit_week
),
trend_analysis AS (
    SELECT 
        id,
        name,
        location,
        REGR_SLOPE(weekly_visits, EXTRACT(EPOCH FROM visit_week)) as trend_slope,
        AVG(weekly_visits) as avg_weekly_visits
    FROM visit_trends
    GROUP BY id, name, location
    HAVING COUNT(*) >= 4  -- At least 4 weeks of data
)
SELECT 
    name,
    ST_Y(location::geometry) as latitude,
    ST_X(location::geometry) as longitude,
    avg_weekly_visits,
    CASE 
        WHEN trend_slope > 0.1 THEN 'Growing'
        WHEN trend_slope < -0.1 THEN 'Declining'
        ELSE 'Stable'
    END as trend_status
FROM trend_analysis
WHERE avg_weekly_visits > 1  -- Filter out low-traffic places
ORDER BY trend_slope DESC;
```

## ë¬¸ì œ í•´ê²°

### ì¼ë°˜ì ì¸ ì„±ëŠ¥ ë¬¸ì œ

#### 1. ëŠë¦° ê³µê°„ ì¿¼ë¦¬
**ì¦ìƒ**: ê³µê°„ ì¿¼ë¦¬ê°€ 1ì´ˆ ì´ìƒ ì†Œìš”ë¨
```sql
-- Diagnose: Check if spatial indexes are being used
EXPLAIN (ANALYZE, BUFFERS) 
SELECT * FROM places 
WHERE ST_DWithin(location::geometry, ST_GeomFromText('POINT(139.7 35.66)', 4326), 100);
```

**Solutions**:
```sql
-- ê³µê°„ ì¸ë±ìŠ¤ê°€ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
CREATE INDEX IF NOT EXISTS idx_places_location_gist 
ON places USING GIST (location);

-- ì§§ì€ ê±°ë¦¬ì—ëŠ” geography ëŒ€ì‹  geometry ì‚¬ìš©
-- (ë¡œì»¬ ì¿¼ë¦¬ì— ë” íš¨ìœ¨ì )
WHERE ST_DWithin(
    location::geometry, 
    ST_GeomFromText('POINT(139.7 35.66)', 4326)::geometry, 
    100
);

-- í™œì„± ì¥ì†Œì— ëŒ€í•œ ë¶€ë¶„ ì¸ë±ìŠ¤ ì¶”ê°€
CREATE INDEX idx_places_location_active_gist 
ON places USING GIST (location) 
WHERE is_active = true;
```

#### 2. ë°°ì—´ ì¿¼ë¦¬ ì„±ëŠ¥
**ì¦ìƒ**: ë°°ì—´ ì»¬ëŸ¼ì— ëŒ€í•œ ì¿¼ë¦¬ê°€ ëŠë¦¼
```sql
-- Diagnose: Check for GIN indexes
\d+ places
```

**Solutions**:
```sql
-- ë°°ì—´ í¬í•¨ì„ ìœ„í•œ GIN ì¸ë±ìŠ¤ ì¶”ê°€
CREATE INDEX idx_places_project_ids_gin ON places USING GIN (project_ids);
CREATE INDEX idx_places_unit_ids_gin ON places USING GIN (unit_ids);

-- ì ì ˆí•œ ë°°ì—´ ì—°ì‚°ì ì‚¬ìš©
SELECT * FROM places WHERE project_ids @> ARRAY[$1::uuid];  -- í¬í•¨
SELECT * FROM places WHERE project_ids && ARRAY[$1::uuid];  -- êµì§‘í•©
```

#### 3. N+1 Query Problems
**Symptoms**: Many individual SELECT queries instead of joins

**Solutions**:
```kotlin
// Use batch loading in services
@Service
class PlaceService {
    fun loadPlacesWithImages(placeIds: List<UUID>): Map<UUID, List<PlaceImage>> {
        return placeImageRepository.findByPlaceIdIn(placeIds)
            .groupBy { it.placeId }
    }
}

// Use entity graphs where appropriate
@EntityGraph(attributePaths = ["images", "placeUnits"])
fun findByIdWithDetails(id: UUID): PlaceEntity?
```

### Database Connection Issues

#### 1. Connection Pool Exhaustion
**Symptoms**: "Connection is not available" errors

**Diagnosis**:
```sql
-- Check current connections
SELECT count(*) as connection_count, state 
FROM pg_stat_activity 
WHERE datname = 'girlsbandtabi'
GROUP BY state;

-- Check for long-running queries
SELECT pid, now() - query_start as duration, query, state
FROM pg_stat_activity
WHERE datname = 'girlsbandtabi'
    AND now() - query_start > interval '5 minutes'
ORDER BY duration DESC;
```

**Solutions**:
```yaml
# Adjust pool configuration
spring:
  datasource:
    hikari:
      maximum-pool-size: 30          # Increase if needed
      leak-detection-threshold: 60000 # Enable leak detection
      
# Application fixes
# 1. Use @Transactional properly
# 2. Close resources in finally blocks
# 3. Avoid long-running transactions
```

#### 2. Lock Contention
**Symptoms**: Queries hanging, timeouts

**Diagnosis**:
```sql
-- Check for locks
SELECT 
    blocked_locks.pid AS blocked_pid,
    blocked_activity.usename AS blocked_user,
    blocking_locks.pid AS blocking_pid,
    blocking_activity.usename AS blocking_user,
    blocked_activity.query AS blocked_statement,
    blocking_activity.query AS current_statement_in_blocking_process
FROM pg_catalog.pg_locks blocked_locks
JOIN pg_catalog.pg_stat_activity blocked_activity 
    ON blocked_activity.pid = blocked_locks.pid
JOIN pg_catalog.pg_locks blocking_locks 
    ON blocking_locks.locktype = blocked_locks.locktype
    AND blocking_locks.DATABASE IS NOT DISTINCT FROM blocked_locks.DATABASE
    AND blocking_locks.relation IS NOT DISTINCT FROM blocked_locks.relation
    AND blocking_locks.page IS NOT DISTINCT FROM blocked_locks.page
    AND blocking_locks.tuple IS NOT DISTINCT FROM blocked_locks.tuple
    AND blocking_locks.virtualxid IS NOT DISTINCT FROM blocked_locks.virtualxid
    AND blocking_locks.transactionid IS NOT DISTINCT FROM blocked_locks.transactionid
    AND blocking_locks.classid IS NOT DISTINCT FROM blocked_locks.classid
    AND blocking_locks.objid IS NOT DISTINCT FROM blocked_locks.objid
    AND blocking_locks.objsubid IS NOT DISTINCT FROM blocked_locks.objsubid
    AND blocking_locks.pid != blocked_locks.pid
JOIN pg_catalog.pg_stat_activity blocking_activity 
    ON blocking_activity.pid = blocking_locks.pid
WHERE NOT blocked_locks.GRANTED;
```

### ë°ì´í„° ì¼ê´€ì„± ë¬¸ì œ

#### 1. ê³ ì•„ ë ˆì½”ë“œ
**íƒì§€**:
```sql
-- ìœ íš¨í•˜ì§€ ì•Šì€ ì§€ì—­ì„ ê°€ì§„ ì¥ì†Œ ì°¾ê¸°
SELECT p.id, p.name, p.region_code
FROM places p
LEFT JOIN regions r ON r.region_code = p.region_code
WHERE p.region_code IS NOT NULL 
    AND r.region_code IS NULL;

-- ì–´ë–¤ ì—”í‹°í‹°ì—ì„œë„ ì°¸ì¡°ë˜ì§€ ì•ŠëŠ” ì—…ë¡œë“œ ì°¾ê¸°
SELECT u.id, u.filename
FROM uploads u
WHERE NOT EXISTS (
    SELECT 1 FROM place_images pi WHERE pi.upload_id = u.id
    UNION
    SELECT 1 FROM news_images ni WHERE ni.upload_id = u.id
    UNION
    SELECT 1 FROM place_photos pp WHERE pp.upload_id = u.id
);
```

#### 2. ë°ì´í„° ë¬´ê²°ì„± ê²€ì¦
```sql
-- Comprehensive integrity check
DO $$
DECLARE
    issue_count INT := 0;
    msg TEXT;
BEGIN
    -- í™•ì¸ 1: ìœ íš¨í•˜ì§€ ì•Šì€ ì¢Œí‘œë¥¼ ê°€ì§„ ì¥ì†Œ
    SELECT COUNT(*) INTO issue_count 
    FROM places 
    WHERE NOT ST_IsValid(location::geometry)
        OR ST_Y(location::geometry) NOT BETWEEN -90 AND 90
        OR ST_X(location::geometry) NOT BETWEEN -180 AND 180;
    
    IF issue_count > 0 THEN
        RAISE WARNING 'Found % places with invalid coordinates', issue_count;
    END IF;
    
    -- í™•ì¸ 2: ê³¼ê±° ë°ì´í„°ì—ì„œ ë¯¸ë˜ ë‚ ì§œ
    SELECT COUNT(*) INTO issue_count
    FROM visit_events
    WHERE created_at > NOW() + INTERVAL '1 day';
    
    IF issue_count > 0 THEN
        RAISE WARNING 'Found % visit events with future timestamps', issue_count;
    END IF;
    
    -- í•„ìš”ì— ë”°ë¼ ì¶”ê°€ í™•ì¸...
END $$;
```

### ì„±ëŠ¥ ì €í•˜

#### 1. í†µê³„ ì •ë³´ êµ¬ì‹í™”
**ì¦ìƒ**: ì¿¼ë¦¬ ê³„íšì´ ê°‘ìê¸° ë¹„íš¨ìœ¨ì ì´ ë¨

**í•´ê²°ë°©ì•ˆ**:
```sql
-- í†µê³„ ì •ë³´ ì—…ë°ì´íŠ¸
ANALYZE;

-- í†µê³„ê°€ ë§ˆì§€ë§‰ìœ¼ë¡œ ì—…ë°ì´íŠ¸ëœ ì‹œì  í™•ì¸
SELECT 
    schemaname,
    tablename,
    n_tup_ins + n_tup_upd + n_tup_del as total_changes,
    last_autoanalyze,
    last_analyze
FROM pg_stat_user_tables 
WHERE schemaname = 'public'
ORDER BY total_changes DESC;

-- ë¬¸ì œê°€ ìˆëŠ” í…Œì´ë¸”ì— ê°•ì œ ë¶„ì„ ì‹¤í–‰
ANALYZE places;
ANALYZE visit_events;
```

#### 2. ì¸ë±ìŠ¤ íŒ½ì°½
**íƒì§€**:
```sql
-- Check index bloat
WITH index_stats AS (
    SELECT 
        schemaname,
        tablename,
        indexname,
        pg_relation_size(indexrelid) as index_size,
        pg_stat_user_indexes.idx_tup_read + pg_stat_user_indexes.idx_tup_fetch as index_usage
    FROM pg_stat_user_indexes
    WHERE schemaname = 'public'
)
SELECT *
FROM index_stats
WHERE index_size > 10 * 1024 * 1024  -- > 10MB
    AND index_usage < 100  -- ë‚®ì€ ì‚¬ìš©ëŸ‰
ORDER BY index_size DESC;
```

**í•´ê²°ë°©ì•ˆ**:
```sql
-- ë™ì‹œ ì¸ë±ìŠ¤ ì¬êµ¬ì¶• (ë¹„ì°¨ë‹¨)
REINDEX INDEX CONCURRENTLY idx_places_location_gist;

-- ì‚¬ìš©í•˜ì§€ ì•ŠëŠ” ì¸ë±ìŠ¤ ì‚­ì œ
DROP INDEX IF EXISTS old_unused_index;
```

---

ì´ ë¬¸ì„œëŠ” Girls Band Tabi ë°ì´í„°ë² ì´ìŠ¤ ì•„í‚¤í…ì²˜ì— ëŒ€í•œ í¬ê´„ì ì¸ ê°€ì´ë“œë¥¼ ì œê³µí•©ë‹ˆë‹¤. ì§ˆë¬¸ì´ë‚˜ ê¸°ì—¬ì— ëŒ€í•´ì„œëŠ” í”„ë¡œì íŠ¸ ë¦¬í¬ì§€í† ë¦¬ë¥¼ ì°¸ì¡°í•˜ê³  ê¸°ì¡´ì˜ ê°œë°œ ì›Œí¬í”Œë¡œìš°ë¥¼ ë”°ë¼ì£¼ì„¸ìš”.

**ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸ (Last Update)**: 2025-11-17  
**ë‹¤ìŒ ë¦¬ë·° (Next Review)**: 2025-12-17
