# ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜ ë¬¸ì„œ v1.0.0 ğŸ›ï¸
**Girls Band Tabi - ê¸°ìˆ  ì•„í‚¤í…ì²˜ ê°€ì´ë“œ**

**ìµœì‹  ì—…ë°ì´íŠ¸**: 2025ë…„ 11ì›” 13ì¼  
**ë²„ì „**: v1.0.0  
**ìƒíƒœ**: âœ… ìµœì‹   

> ê±¸ì¦ˆë°´ë“œíƒ€ë¹„ í”„ë¡œì íŠ¸ì˜ í¬ê´„ì ì¸ ê¸°ìˆ  ì•„í‚¤í…ì²˜ ë¬¸ì„œ

## ëª©ì°¨

1. [ê°œìš”](#ê°œìš”)
2. [ê¸°ìˆ  ìŠ¤íƒ](#ê¸°ìˆ -ìŠ¤íƒ)
3. [ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜](#ì‹œìŠ¤í…œ-ì•„í‚¤í…ì²˜)
4. [ëª¨ë“ˆ êµ¬ì¡°ì™€ ê²½ê³„](#ëª¨ë“ˆ-êµ¬ì¡°ì™€-ê²½ê³„)
5. [ë„ë©”ì¸ ì£¼ë„ ì„¤ê³„ íŒ¨í„´](#ë„ë©”ì¸-ì£¼ë„-ì„¤ê³„-íŒ¨í„´)
6. [ì„œë¹„ìŠ¤ ë ˆì´ì–´ ì•„í‚¤í…ì²˜](#ì„œë¹„ìŠ¤-ë ˆì´ì–´-ì•„í‚¤í…ì²˜)
7. [ë°ì´í„° íë¦„ê³¼ ì²˜ë¦¬](#ë°ì´í„°-íë¦„ê³¼-ì²˜ë¦¬)
8. [í†µí•© íŒ¨í„´](#í†µí•©-íŒ¨í„´)
9. [ê³µê°„ ë°ì´í„° ì•„í‚¤í…ì²˜](#ê³µê°„-ë°ì´í„°-ì•„í‚¤í…ì²˜)
10. [ìºì‹± ì „ëµ](#ìºì‹±-ì „ëµ)
11. [ì´ë²¤íŠ¸ ê¸°ë°˜ íŒ¨í„´](#ì´ë²¤íŠ¸-ê¸°ë°˜-íŒ¨í„´)
12. [ë³´ì•ˆ ì•„í‚¤í…ì²˜](#ë³´ì•ˆ-ì•„í‚¤í…ì²˜)
13. [í™•ì¥ì„± ê³ ë ¤ì‚¬í•­](#í™•ì¥ì„±-ê³ ë ¤ì‚¬í•­)
14. [ë°°í¬ íŒ¨í„´](#ë°°í¬-íŒ¨í„´)
15. [ë¯¸ë˜ ë°œì „ ë¡œë“œë§µ](#ë¯¸ë˜-ë°œì „-ë¡œë“œë§µ)

---

## ê°œìš”

Girls Band TabiëŠ” ì• ë‹ˆë©”ì´ì…˜ê³¼ ìŒì•… íŒ¬ì„ ìœ„í•œ **ìœ„ì¹˜ ê¸°ë°˜ ì„±ì§€ìˆœë¡€ í”Œë«í¼**ìœ¼ë¡œ, **Spring Boot 3.x**ì™€ **Spring MVC + JPA** ìŠ¤íƒì„ ì‚¬ìš©í•˜ì—¬ êµ¬ì¶•ë˜ì—ˆìŠµë‹ˆë‹¤. ì´ ì‹œìŠ¤í…œì€ ë‹¤ì–‘í•œ ë°´ë“œ í”„ëœì°¨ì´ì¦ˆ(Girls Band Cry, BanG Dream! ë“±)ë¥¼ ìœ„í•œ ë©€í‹° í”„ë¡œì íŠ¸ ì•„í‚¤í…ì²˜ë¥¼ ì •êµí•œ ê³µê°„ì •ë³´ ê¸°ëŠ¥ê³¼ í•¨ê»˜ ì§€ì›í•©ë‹ˆë‹¤.

### í•µì‹¬ ë¹„ì¦ˆë‹ˆìŠ¤ ë„ë©”ì¸
- **ì‚¬ìš©ì ê´€ë¦¬**: ì¸ì¦, í”„ë¡œí•„, ì—­í•  ê¸°ë°˜ ì ‘ê·¼ ì œì–´
- **í”„ë¡œì íŠ¸ ê´€ë¦¬**: ë©€í‹° ë°´ë“œ í”„ëœì°¨ì´ì¦ˆ ì§€ì›
- **ê³µê°„ì •ë³´ ì„œë¹„ìŠ¤**: ìœ„ì¹˜ ê²€ì¦, ì„±ì§€ìˆœë¡€ ì‚¬ì´íŠ¸
- **ì½˜í…ì¸  ê´€ë¦¬**: ë‰´ìŠ¤, ë¯¸ë””ì–´, ë¼ì´ë¸Œ ì´ë²¤íŠ¸
- **ì»¤ë®¤ë‹ˆí‹° ê¸°ëŠ¥**: ê²Œì‹œë¬¼, ëŒ“ê¸€, ì¦ê²¨ì°¾ê¸°
- **ë¶„ì„**: ë°©ë¬¸ ì¶”ì , ì‚¬ìš©ì ì¸ì‚¬ì´íŠ¸

### ì•„í‚¤í…ì²˜ ì›ì¹™
1. **ìº¡ìŠí™”**: ìµœì†Œí•œì˜ ê²°í•©ë„ë¥¼ ê°€ì§„ ëª…í™•í•œ ëª¨ë“ˆ ê²½ê³„
2. **ê´€ì‹¬ì‚¬ì˜ ë¶„ë¦¬**: í”„ë ˆì  í…Œì´ì…˜, ë¹„ì¦ˆë‹ˆìŠ¤, ì˜ì†ì„±ì„ ìœ„í•œ êµ¬ë³„ëœ ë ˆì´ì–´
3. **í™•ì¥ì„±**: ìƒˆë¡œìš´ ê¸°ëŠ¥ì„ ìœ„í•œ í”ŒëŸ¬ê·¸ì¸ ê¸°ë°˜ ì•„í‚¤í…ì²˜
4. **ë³´ì•ˆ ìš°ì„ **: ì¸ì¦, ê¶Œí•œ ë¶€ì—¬, ê°ì‚¬ ë¡œê¹…
5. **ì„±ëŠ¥**: ìºì‹± ì „ëµ, ì¿¼ë¦¬ ìµœì í™”, ê³µê°„ ì¸ë±ì‹±

---

## ê¸°ìˆ  ìŠ¤íƒ

### í•µì‹¬ í”„ë ˆì„ì›Œí¬ ìŠ¤íƒ
```yaml
Framework: Spring Boot 3.3.4
Language: Kotlin 2.0.21
JVM: OpenJDK 21
Architecture: Spring MVC (blocking) + JPA
```

### ë°ì´í„°ë² ì´ìŠ¤ ë° ì˜ì†ì„±
```yaml
Primary Database: PostgreSQL 15 with PostGIS 3.3
ORM: Hibernate 6.x with Spatial Support (ê³µê°„ì •ë³´ ì§€ì›)
Connection Pool: HikariCP
Migration Tool: Flyway 10.18.0
Spatial Library: JTS (Java Topology Suite)
```

### ìºì‹± ë° ì„±ëŠ¥
```yaml
L1 Cache: Caffeine (in-memory, ë©”ëª¨ë¦¬ ë‚´ ìºì‹œ)
L2 Cache: Redis 7 (distributed, ë¶„ì‚° ìºì‹œ)
Session Store: Redis
Cache Manager: Spring Cache Abstraction
```

### ë³´ì•ˆ ë° ì¸ì¦
```yaml
Framework: Spring Security 6.x
JWT Library: JJWT 0.12.6
OAuth2: Google, Apple providers
Password Hashing: BCrypt with pepper
Session Management: Redis-backed
```

### ì™¸ë¶€ í†µí•©
```yaml
File Storage: Cloudflare R2 (S3-compatible)
Observability: Micrometer + Prometheus
Documentation: SpringDoc OpenAPI 3.1
Build Tool: Gradle 8.x with Kotlin DSL
```

### ê°œë°œ ë° í’ˆì§ˆ
```yaml
Code Style: Google Style Guide (Kotlin/Java)
Linting: KTLint + Detekt
Testing: JUnit 5 + Testcontainers
Container: Docker with multi-stage builds
```

---

## ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜

### ê³ ìˆ˜ì¤€ ì•„í‚¤í…ì²˜ ë‹¤ì´ì–´ê·¸ë¨

![ê³ ìˆ˜ì¤€ ì•„í‚¤í…ì²˜ ë‹¤ì´ì–´ê·¸ë¨](https://mermaid.ink/img/hVVNb6MwEL3zK6yetlq1h3bPKxFCs674Wpu0K1lV5BCXeEUhMqZt_v0OJkBxiJYTzLz4zTy_meSKH_YoXTgInrrZ5ub7yiukKDUK-FGoK5Nrn2d_wZ7FFj2oqtSi3L0MmTBe4MBnYbWVhUDu4TCm3ARvvAD7UcrgFXUn110eznAs5hXX4oMfbepohaM_LMpl-YkSVX0eRwLipv4mwCFOGYEfo0C-SS3L_CIFlFfIjGtZlTYNTQiOVoweFByAFlWl0f3t_e2PF2eAjOckStTQy-xB7eOlJGDEpynyQC9VFYVQ9csEQn2PUZE1SuojepCFPkM8uQFesideyJ0hGrNDZ9OqqFDvMhNzBSUkftzQJ4-Bgn9FptEJO2VMAtfzO1jB4aBZ0Jr6xGDWtVDzkNBfYtdgQrGTfB4U-c_UYCLxUZ9DLvS4rN64nNUcbIZT7FP2mLjILzU4QViKEj-JKSPiUNVSV-qIMJhZvUKrFnAZhy6ONkG8wh7rKatcZtP6LrgMl6-K11o1mW7U2XV86YVr0AYK4bmwrium6Qr8w74lVa1zJejvAH1H7ccK02u7qyUGJAGpa-TxbC-u_yuj_wmNl7zoda-n_OSOeUXV7F4LDg2Quylh7K7TXyx2G71vJ_Jd7ibevUAZb8Ev7xzWBDh-Sgc6U0Z7wXat1LXtqJRgj7b2fRN6L5oahUIrmVm4lICD2VKC-nLbaDgrVTwbVsLsxcFuQzc3P7tF44w7zQqO28xKmDcTG_eRM11PJtsuBaffDiYCO8A57QLzbSbeGWbfxPrJtcP9qFrxfjqt8DCRVrwfwk6Jnsuk-nlyJpvhPNUznmcG0vNUzzvNOF_nuFO0nVhnmN2u9dNwzNRsRmGm4DE-qbYLz9RK7ib3Ygzf4bq_CRNtXWvHTj61w8aWzj8=)

<details>
<summary>Mermaid ì›ë³¸ ì½”ë“œ ë³´ê¸°</summary>

```mermaid
graph TB
    subgraph "Client Layer"
        WEB["Web Frontend (ì›¹ í”„ë¡ íŠ¸ì—”ë“œ)"]
        MOBILE["Mobile App (ëª¨ë°”ì¼ ì•±)"]
        API_CLIENT["API Clients (API í´ë¼ì´ì–¸íŠ¸)"]
    end
    
    subgraph "Gateway Layer"
        NGINX["Nginx Proxy (ì—”ì§„ì—‘ìŠ¤ í”„ë¡ì‹œ)"]
        RATE_LIMIT["Rate Limiting (ì†ë„ ì œí•œ)"]
    end
    
    subgraph "Application Layer"
        SPRING["Spring Boot 3.3.4"]
        
        subgraph "Presentation Layer"
            CTRL["REST Controllers (REST ì»¨íŠ¸ë¡¤ëŸ¬)"]
            SEC["Security Filters (ë³´ì•ˆ í•„í„°)"]
            VALID["Validation (ê²€ì¦)"]
        end
        
        subgraph "Service Layer"
            PROJ_SVC["Project Service (í”„ë¡œì íŠ¸ ì„œë¹„ìŠ¤)"]
            PLACE_SVC["Place Service (ì¥ì†Œ ì„œë¹„ìŠ¤)"]
            USER_SVC["User Service (ì‚¬ìš©ì ì„œë¹„ìŠ¤)"]
            MEDIA_SVC["Media Service (ë¯¸ë””ì–´ ì„œë¹„ìŠ¤)"]
            NEWS_SVC["News Service (ë‰´ìŠ¤ ì„œë¹„ìŠ¤)"]
        end
        
        subgraph "Domain Layer"
            ENTITIES["JPA Entities (JPA ì—”í‹°í‹°)"]
            REPOS["Repository Interfaces (ë¦¬í¬ì§€í† ë¦¬ ì¸í„°í˜ì´ìŠ¤)"]
            DOMAIN_LOGIC["Domain Logic (ë„ë©”ì¸ ë¡œì§)"]
        end
    end
    
    subgraph "Infrastructure Layer"
        subgraph "Data Storage"
            POSTGRES["(PostgreSQL + PostGIS)"]
            REDIS["(Redis Cache)"]
        end
        
        subgraph "External Services"
            R2["Cloudflare R2 (í´ë¼ìš°ë“œí”Œë ˆì–´ R2)"]
            OAUTH["OAuth Providers (OAuth ì œê³µì)"]
        end
        
        subgraph "Observability"
            LOGS["Structured Logs (êµ¬ì¡°í™”ëœ ë¡œê·¸)"]
            METRICS["Prometheus Metrics (í”„ë¡œë©”í…Œìš°ìŠ¤ ë©”íŠ¸ë¦­)"]
            TRACE["Distributed Tracing (ë¶„ì‚° ì¶”ì )"]
        end
    end
    
    WEB --> NGINX
    MOBILE --> NGINX
    API_CLIENT --> NGINX
    NGINX --> RATE_LIMIT
    RATE_LIMIT --> CTRL
    CTRL --> SEC
    SEC --> VALID
    VALID --> PROJ_SVC
    VALID --> PLACE_SVC
    VALID --> USER_SVC
    VALID --> MEDIA_SVC
    VALID --> NEWS_SVC
    
    PROJ_SVC --> ENTITIES
    PLACE_SVC --> ENTITIES
    USER_SVC --> ENTITIES
    MEDIA_SVC --> ENTITIES
    NEWS_SVC --> ENTITIES
    
    ENTITIES --> REPOS
    REPOS --> POSTGRES
    
    PROJ_SVC --> REDIS
    PLACE_SVC --> REDIS
    USER_SVC --> REDIS
    
    MEDIA_SVC --> R2
    SEC --> OAUTH
    
    SPRING --> LOGS
    SPRING --> METRICS
    SPRING --> TRACE
```

<!-- ì „ì²´ ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜ êµ¬ì¡° -->
![ì „ì²´ ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜ êµ¬ì¡°](./diagrams/ì‹œìŠ¤í…œì•„í‚¤í…ì²˜_v2025.11.13_diagram_1.svg)

<!-- í˜¸í™˜ì„±ì„ ìœ„í•œ PNG ë²„ì „ -->
![ì „ì²´ ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜ êµ¬ì¡° (PNG)](./images/ì‹œìŠ¤í…œì•„í‚¤í…ì²˜_v2025.11.13_diagram_1.png)


</details>

### í˜„ì¬ êµ¬í˜„: MVC + JPA ìŠ¤íƒ

ì‹œìŠ¤í…œì€ í˜„ì¬ JPAì™€ í•¨ê»˜ **ë¸”ë¡œí‚¹ MVC ì•„í‚¤í…ì²˜**ë¥¼ ì‚¬ìš©í•˜ì—¬ ë‹¤ìŒì„ ì œê³µí•©ë‹ˆë‹¤:
- **ì¼ê´€ì„±**: ë‹¨ì¼ ìŠ¤ë ˆë“œ ëª¨ë¸ë¡œ ì¶”ë¡ ì´ ê°„ë‹¨í•¨
- **ì•ˆì •ì„±**: ê´‘ë²”ìœ„í•œ ë„êµ¬ë¥¼ ê°–ì¶˜ ì„±ìˆ™í•œ Spring ìƒíƒœê³„
- **ì„±ëŠ¥**: ìºì‹± ìµœì í™”ë¡œ í˜„ì¬ ê·œëª¨ì— ì¶©ë¶„
- **ê°œë°œì ê²½í—˜**: ìµìˆ™í•œ íŒ¨í„´, ê´‘ë²”ìœ„í•œ ë¬¸ì„œ

**ì•„í‚¤í…ì²˜ ê²°ì •**: í”„ë¡œì íŠ¸ëŠ” ì›ë˜ WebFlux + R2DBCë¥¼ ê³„íší–ˆì§€ë§Œ ë‹¤ìŒ ì´ìœ ë¡œ MVC + JPAë¡œ ë§ˆì´ê·¸ë ˆì´ì…˜í–ˆìŠµë‹ˆë‹¤:
1. **ë‹¨ìˆœì„±**: ë” ì‰¬ìš´ ë””ë²„ê¹…ê³¼ ë¬¸ì œ í•´ê²°
2. **ìƒíƒœê³„ ì„±ìˆ™ë„**: ë” ë‚˜ì€ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì§€ì›ê³¼ ì»¤ë®¤ë‹ˆí‹° ë¦¬ì†ŒìŠ¤
3. **ê³µê°„ì •ë³´ ì§€ì›**: Hibernate Spatialê³¼ì˜ ì™„ì „í•œ PostGIS í†µí•©
4. **íŒ€ ì¹œìˆ™ë„**: ê¸°ì—¬ìë“¤ì˜ í•™ìŠµ ê³¡ì„  ê°ì†Œ

---

## ëª¨ë“ˆ êµ¬ì¡°ì™€ ê²½ê³„

### íŒ¨í‚¤ì§€ êµ¬ì¡° (í˜„ì¬ êµ¬í˜„)

```
org.pyrimidines.girlsbandtabi/
â”œâ”€â”€ config/                    # êµ¬ì„± ë¹ˆ
â”‚   â”œâ”€â”€ SecurityConfig         # ë³´ì•ˆ ë° ì¸ì¦
â”‚   â”œâ”€â”€ CacheConfig           # ìºì‹± ì „ëµ
â”‚   â”œâ”€â”€ OpenApiConfig         # API ë¬¸ì„œí™”
â”‚   â””â”€â”€ WebMvcConfig          # ì›¹ ë ˆì´ì–´ êµ¬ì„±
â”‚
â”œâ”€â”€ gateway/rest/             # REST API ì—”ë“œí¬ì¸íŠ¸
â”‚   â”œâ”€â”€ ProjectController     # í”„ë¡œì íŠ¸ ê´€ë¦¬
â”‚   â”œâ”€â”€ PlaceController       # ê³µê°„ì •ë³´ ì‘ì—…
â”‚   â”œâ”€â”€ UserController        # ì‚¬ìš©ì í”„ë¡œí•„
â”‚   â”œâ”€â”€ MediaController       # íŒŒì¼ ì—…ë¡œë“œ/ë‹¤ìš´ë¡œë“œ
â”‚   â””â”€â”€ admin/                # ê´€ë¦¬ì ì—”ë“œí¬ì¸íŠ¸
â”‚
â”œâ”€â”€ service/                  # ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ë ˆì´ì–´
â”‚   â”œâ”€â”€ ProjectService        # í”„ë¡œì íŠ¸ ì‘ì—…
â”‚   â”œâ”€â”€ PlaceService          # ê³µê°„ ì¿¼ë¦¬
â”‚   â”œâ”€â”€ UserService           # ì‚¬ìš©ì ê´€ë¦¬
â”‚   â”œâ”€â”€ MediaService          # íŒŒì¼ ì²˜ë¦¬
â”‚   â””â”€â”€ CacheEvictionService  # ìºì‹œ ê´€ë¦¬
â”‚
â”œâ”€â”€ persistence/              # ë°ì´í„° ì ‘ê·¼ ë ˆì´ì–´
â”‚   â”œâ”€â”€ entity/              # JPA ì—”í‹°í‹°
â”‚   â”‚   â”œâ”€â”€ PlaceEntity       # ê³µê°„ ë°ì´í„° ëª¨ë¸
â”‚   â”‚   â”œâ”€â”€ UserEntity        # ì‚¬ìš©ì í”„ë¡œí•„
â”‚   â”‚   â””â”€â”€ ProjectEntity     # í”„ë¡œì íŠ¸ ë©”íƒ€ë°ì´í„°
â”‚   â””â”€â”€ repo/                # ë¦¬í¬ì§€í† ë¦¬ ì¸í„°í˜ì´ìŠ¤
â”‚       â”œâ”€â”€ PlaceRepository   # ê³µê°„ ì¿¼ë¦¬
â”‚       â”œâ”€â”€ UserRepository    # ì‚¬ìš©ì ë°ì´í„° ì ‘ê·¼
â”‚       â””â”€â”€ ProjectRepository # í”„ë¡œì íŠ¸ ì‘ì—…
â”‚
â”œâ”€â”€ dto/                     # ë°ì´í„° ì „ì†¡ ê°ì²´
â”‚   â”œâ”€â”€ project/             # í”„ë¡œì íŠ¸ ê´€ë ¨ DTO
â”‚   â”œâ”€â”€ place/               # ìœ„ì¹˜ DTO
â”‚   â”œâ”€â”€ user/                # ì‚¬ìš©ì DTO
â”‚   â””â”€â”€ common/              # ê³µìœ  ì‘ë‹µ íƒ€ì…
â”‚
â”œâ”€â”€ security/                # ë³´ì•ˆ í”„ë ˆì„ì›Œí¬
â”‚   â”œâ”€â”€ JwtService           # í† í° ê´€ë¦¬
â”‚   â”œâ”€â”€ CurrentUserResolver  # ì‚¬ìš©ì ì»¨í…ìŠ¤íŠ¸
â”‚   â””â”€â”€ project/             # í”„ë¡œì íŠ¸ ë ˆë²¨ ê¶Œí•œ ë¶€ì—¬
â”‚
â””â”€â”€ exception/               # ì˜ˆì™¸ ì²˜ë¦¬
    â”œâ”€â”€ GlobalExceptionHandler
    â””â”€â”€ ë„ë©”ì¸ë³„ ì˜ˆì™¸
```

### ë¯¸ë˜ Modulith ê²½ê³„

ë” ë‚˜ì€ ìº¡ìŠí™”ë¥¼ ìœ„í•œ **Spring Modulith ë§ˆì´ê·¸ë ˆì´ì…˜ ê³„íš**:

```
modules/
â”œâ”€â”€ user/                    # ì‚¬ìš©ì ê´€ë¦¬ ëª¨ë“ˆ
â”‚   â”œâ”€â”€ application/         # ì‚¬ìš© ì‚¬ë¡€ ë° ì„œë¹„ìŠ¤
â”‚   â”œâ”€â”€ domain/             # í•µì‹¬ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§
â”‚   â””â”€â”€ infrastructure/     # ë°ì´í„° ì ‘ê·¼, ì™¸ë¶€ ì„œë¹„ìŠ¤
â”‚
â”œâ”€â”€ project/                # í”„ë¡œì íŠ¸ ê´€ë¦¬ ëª¨ë“ˆ
â”‚   â”œâ”€â”€ application/
â”‚   â”œâ”€â”€ domain/
â”‚   â””â”€â”€ infrastructure/
â”‚
â”œâ”€â”€ place/                  # ê³µê°„ì •ë³´ ëª¨ë“ˆ
â”‚   â”œâ”€â”€ application/
â”‚   â”œâ”€â”€ domain/
â”‚   â””â”€â”€ infrastructure/
â”‚
â”œâ”€â”€ media/                  # ì½˜í…ì¸  ê´€ë¦¬ ëª¨ë“ˆ
â”‚   â”œâ”€â”€ application/
â”‚   â”œâ”€â”€ domain/
â”‚   â””â”€â”€ infrastructure/
â”‚
â””â”€â”€ shared/                 # ê³µìœ  ì»¤ë„
    â”œâ”€â”€ domain/             # ê³µí†µ ê°’ ê°ì²´
    â”œâ”€â”€ infrastructure/     # ê³µìœ  ìœ í‹¸ë¦¬í‹°
    â””â”€â”€ events/             # ë„ë©”ì¸ ì´ë²¤íŠ¸
```

**ëª¨ë“ˆ í†µì‹  ê·œì¹™**:
- **ë‚´ë¶€**: ëª¨ë“ˆ ê²½ê³„ ë‚´ì—ì„œ ì§ì ‘ ë©”ì„œë“œ í˜¸ì¶œ
- **ëª¨ë“ˆ ê°„**: ì´ë²¤íŠ¸ ë˜ëŠ” ì˜ ì •ì˜ëœ ì„œë¹„ìŠ¤ ì¸í„°í˜ì´ìŠ¤
- **ì™¸ë¶€**: ì„œë“œíŒŒí‹° í†µí•©ì„ ìœ„í•œ ì–´ëŒ‘í„° íŒ¨í„´

---

## ë„ë©”ì¸ ì£¼ë„ ì„¤ê³„ íŒ¨í„´

### ë„ë©”ì¸ ëª¨ë¸ ì•„í‚¤í…ì²˜

ì‹œìŠ¤í…œì€ í’ë¶€í•œ ë„ë©”ì¸ ì—”í‹°í‹°ë¥¼ ê°€ì§„ **DDD ì „ìˆ  íŒ¨í„´**ì„ ë”°ë¦…ë‹ˆë‹¤:

#### ì• ê·¸ë¦¬ê²Œì´íŠ¸ ë£¨íŠ¸
```kotlin
// ì˜ˆì‹œ: Place ì• ê·¸ë¦¬ê²Œì´íŠ¸
@Entity
class PlaceEntity(
    val id: UUID,
    val projectId: UUID,
    val name: String,
    val location: Point,  // PostGIS ê³µê°„ íƒ€ì…
    val verificationRadiusM: Int = 10,
    // ... ë„ë©”ì¸ ë¡œì§ ë©”ì„œë“œ
) {
    // ë„ë©”ì¸ í–‰ë™
    fun isWithinVerificationRadius(userLocation: Point): Boolean
    fun associateWithUnit(unitId: UUID)
    fun normalizedPlaceTypes(): List<String>
}
```

#### ê°’ ê°ì²´ (Value Objects)
```kotlin
// ê²€ì¦ì´ í¬í•¨ëœ ê³µê°„ ì¢Œí‘œ
data class Coordinates(val latitude: Double, val longitude: Double) {
    init {
        require(latitude in -90.0..90.0) { "Invalid latitude" }
        require(longitude in -180.0..180.0) { "Invalid longitude" }
    }
}

// ì¡°ì‘ ë°©ì§€ ê²€ì¦ì´ í¬í•¨ëœ ìœ„ì¹˜ ìš”ì²­
data class LocationClaim(
    val coordinates: Coordinates,
    val accuracy: Double,
    val timestamp: OffsetDateTime,
    val deviceId: String?
)
```

#### ë¦¬í¬ì§€í† ë¦¬ íŒ¨í„´
```kotlin
interface PlaceRepository : JpaRepository<PlaceEntity, UUID> {
    // ë„¤ì´í‹°ë¸Œ PostGIS í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•œ ê³µê°„ ì¿¼ë¦¬
    @Query("""
        SELECT p FROM PlaceEntity p 
        WHERE ST_DWithin(p.location, ST_Point(:longitude, :latitude, 4326), :radiusM)
        AND p.isActive = true
    """)
    fun findWithinRadius(
        latitude: Double, 
        longitude: Double, 
        radiusM: Double
    ): List<PlaceEntity>
    
    // ë°°ì—´ ì—°ì‚°ì„ ì‚¬ìš©í•œ í”„ë¡œì íŠ¸ ë²”ìœ„ ì¿¼ë¦¬
    @Query("""
        SELECT p FROM PlaceEntity p 
        WHERE :projectId = ANY(p.projectIds) 
        AND p.isActive = true
    """)
    fun findByProjectId(projectId: UUID): List<PlaceEntity>
}
```

### ë„ë©”ì¸ ì´ë²¤íŠ¸ (ë¯¸ë˜ ê°œì„ ì‚¬í•­)

ëŠìŠ¨í•œ ê²°í•©ì„ ìœ„í•œ **ì´ë²¤íŠ¸ ê¸°ë°˜ ì•„í‚¤í…ì²˜ ê³„íš**:

```kotlin
// ëª¨ë“ˆ ê°„ í†µì‹ ì„ ìœ„í•œ ë„ë©”ì¸ ì´ë²¤íŠ¸
sealed class DomainEvent {
    abstract val aggregateId: UUID
    abstract val occurredOn: OffsetDateTime
}

data class PlaceVisitedEvent(
    override val aggregateId: UUID,
    override val occurredOn: OffsetDateTime,
    val userId: UUID,
    val placeId: UUID,
    val verificationMethod: String
) : DomainEvent()

data class UserRegisteredEvent(
    override val aggregateId: UUID,
    override val occurredOn: OffsetDateTime,
    val email: String,
    val displayName: String
) : DomainEvent()
```

---

## ì„œë¹„ìŠ¤ ë ˆì´ì–´ ì•„í‚¤í…ì²˜

### ì„œë¹„ìŠ¤ ì„¤ê³„ ì›ì¹™

1. **ë‹¨ì¼ ì±…ì„**: ê° ì„œë¹„ìŠ¤ëŠ” í•˜ë‚˜ì˜ ë„ë©”ì¸ ì˜ì—­ì„ ê´€ë¦¬
2. **íŠ¸ëœì­ì…˜ ê²½ê³„**: ì„œë¹„ìŠ¤ê°€ íŠ¸ëœì­ì…˜ ë²”ìœ„ë¥¼ ì •ì˜
3. **ìºì‹± í†µí•©**: ì„±ëŠ¥ì„ ìœ„í•œ ì „ëµì  ìºì‹œ ì‚¬ìš©
4. **ì˜¤ë¥˜ ì²˜ë¦¬**: ì¼ê´€ëœ ì˜ˆì™¸ ë³€í™˜

### ì„œë¹„ìŠ¤ êµ¬í˜„ ì˜ˆì‹œ

```kotlin
@Service
@Transactional(readOnly = true)
class PlaceService(
    private val placeRepository: PlaceRepository,
    private val placeImageRepository: PlaceImageRepository,
    private val regionService: RegionService,
    private val cacheManager: CacheManager
) {
    
    @Cacheable("place:detail", key = "#placeId")
    fun getPlaceWithImages(placeId: UUID): PlaceDetailDto {
        val place = placeRepository.findByIdOrThrow(placeId)
        
        // N+1 ì¿¼ë¦¬ë¥¼ í”¼í•˜ê¸° ìœ„í•œ ì• í”Œë¦¬ì¼€ì´ì…˜ ê´€ë¦¬ ê´€ê³„
        place.images = placeImageRepository.findByPlaceId(placeId).toMutableList()
        place.region = regionService.findByCode(place.regionCode)
        
        return place.toDetailDto()
    }
    
    @Transactional
    @CacheEvict("place:list", allEntries = true)
    fun createPlace(request: CreatePlaceRequest): PlaceDto {
        val place = PlaceEntity(
            projectId = request.projectId,
            name = request.name,
            location = geometryFactory.createPoint(
                Coordinate(request.longitude, request.latitude)
            ),
            verificationRadiusM = request.verificationRadius ?: 10
        )
        
        return placeRepository.save(place).toDto()
    }
    
    // ìºì‹±ì´ í¬í•¨ëœ ê³µê°„ ì¿¼ë¦¬
    @Cacheable("place:geo-bounds")
    fun findPlacesInBounds(
        bounds: GeoBounds,
        projectIds: List<UUID>
    ): List<PlaceSummaryDto> {
        return placeRepository.findInBoundsWithProjects(
            bounds.southwest.latitude, bounds.southwest.longitude,
            bounds.northeast.latitude, bounds.northeast.longitude,
            projectIds
        ).map { it.toSummaryDto() }
    }
}
```

### ì„œë¹„ìŠ¤ ë ˆì´ì–´ì˜ ì¥ì 

- **íŠ¸ëœì­ì…˜ ê´€ë¦¬**: Springì„ í†µí•œ ìë™ íŠ¸ëœì­ì…˜ ì²˜ë¦¬
- **ìºì‹œ í†µí•©**: ì œê±° ì „ëµì´ í¬í•¨ëœ ì„ ì–¸ì  ìºì‹±
- **ê²€ì¦**: ì„œë¹„ìŠ¤ ê²½ê³„ì—ì„œì˜ Bean Validation í†µí•©
- **ì˜¤ë¥˜ ë³€í™˜**: ë¦¬í¬ì§€í† ë¦¬ ì˜ˆì™¸ë¥¼ ë„ë©”ì¸ ì˜ˆì™¸ë¡œ ë³€í™˜
- **ì„±ëŠ¥ ìµœì í™”**: ì¿¼ë¦¬ ë°°ì¹˜ ì²˜ë¦¬ ë° ê´€ê³„ ê´€ë¦¬

---

## ë°ì´í„° íë¦„ê³¼ ì²˜ë¦¬ íŒ¨í„´

### ìš”ì²­ ì²˜ë¦¬ íë¦„

![ìš”ì²­ ì²˜ë¦¬ ì‹œí€€ìŠ¤ ë‹¤ì´ì–´ê·¸ë¨](https://mermaid.ink/img/bZJNcsMgDIX3OQUXyAVYZFE7M1mkk8T2dE-wJlFLwUW4U9--gPF_WDF6T9InAcFPC1pCjuJhxfeO-dMI61BiI7RjmULQbhs22lmjFNiN9CEU1sKZrVKC_UUJm3gBjSH0Gd1GyoUTd0HbnEzIJ-xiuEfcHw4TFGenqrr6wn446ukn0TtHRj7gwsI86t6bqDm7WiOBiL21hDpczuaBMvqTJzAELs6yJ8ivBBkMQiVkdsK-RWQKkf28RwGutboX6jh9NIMiSPnvSDQWmPpOO-Ts1oLtlqsLZ7J4_6BydvwD2fr5y9t5tA7qflU54RVArXL0qvJ8mKN26Dp2uX-CdK-g07JKnwkM9WxfoOvFYlevmzjy6rJ-22CM_2H8AtQY7bfwDw==)

<details>
<summary>Mermaid ì›ë³¸ ì½”ë“œ ë³´ê¸°</summary>

```mermaid
sequenceDiagram
    participant Client %% EN: Client / KO: í´ë¼ì´ì–¸íŠ¸
    participant Controller %% EN: Controller / KO: ì»¨íŠ¸ë¡¤ëŸ¬
    participant Validator %% EN: Validator / KO: ê²€ì¦ì
    participant Service %% EN: Service / KO: ì„œë¹„ìŠ¤
    participant Repository %% EN: Repository / KO: ë¦¬í¬ì§€í† ë¦¬
    participant Database %% EN: Database / KO: ë°ì´í„°ë² ì´ìŠ¤
    participant Cache %% EN: Cache / KO: ìºì‹œ
    
    Client->>Controller: HTTP Request %% EN: HTTP Request / KO: HTTP ìš”ì²­
    Controller->>Validator: Validate Request %% EN: Validate Request / KO: ìš”ì²­ ê²€ì¦
    Validator->>Service: Process Business Logic %% EN: Process Business Logic / KO: ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ì²˜ë¦¬
    Service->>Cache: Check Cache %% EN: Check Cache / KO: ìºì‹œ í™•ì¸
    alt Cache Hit %% EN: Cache Hit / KO: ìºì‹œ íˆíŠ¸
        Cache-->>Service: Return Cached Data %% EN: Return Cached Data / KO: ìºì‹œëœ ë°ì´í„° ë°˜í™˜
    else Cache Miss %% EN: Cache Miss / KO: ìºì‹œ ë¯¸ìŠ¤
        Service->>Repository: Query Database %% EN: Query Database / KO: ë°ì´í„°ë² ì´ìŠ¤ ì¡°íšŒ
        Repository->>Database: Execute SQL %% EN: Execute SQL / KO: SQL ì‹¤í–‰
        Database-->>Repository: Return Results %% EN: Return Results / KO: ê²°ê³¼ ë°˜í™˜
        Repository-->>Service: Entity Objects %% EN: Entity Objects / KO: ì—”í‹°í‹° ê°ì²´
        Service->>Cache: Store in Cache %% EN: Store in Cache / KO: ìºì‹œì— ì €ì¥
    end
    Service-->>Controller: Return DTO %% EN: Return DTO / KO: DTO ë°˜í™˜
    Controller-->>Client: HTTP Response %% EN: HTTP Response / KO: HTTP ì‘ë‹µ
```

<!-- ë°ì´í„° ì²˜ë¦¬ ì‹œí€€ìŠ¤ í”Œë¡œìš° -->
![ë°ì´í„° ì²˜ë¦¬ ì‹œí€€ìŠ¤ í”Œë¡œìš°](./diagrams/ì‹œìŠ¤í…œì•„í‚¤í…ì²˜_v2025.11.13_diagram_2.svg)

<!-- í˜¸í™˜ì„±ì„ ìœ„í•œ PNG ë²„ì „ -->
![ë°ì´í„° ì²˜ë¦¬ ì‹œí€€ìŠ¤ í”Œë¡œìš° (PNG)](./images/ì‹œìŠ¤í…œì•„í‚¤í…ì²˜_v2025.11.13_diagram_2.png)


</details>

### ë°ì´í„° ë³€í™˜ ë ˆì´ì–´

1. **HTTP â†’ DTO**: ìš”ì²­ ë°”ì¸ë”© ë° ê²€ì¦
2. **DTO â†’ Entity**: ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ì ìš©
3. **Entity â†’ Database**: JPA ì˜ì†ì„±
4. **Database â†’ Entity**: ì¿¼ë¦¬ ê²°ê³¼ ë§¤í•‘
5. **Entity â†’ DTO**: ì‘ë‹µ ì§ë ¬í™”

### ê³µê°„ ë°ì´í„° ì²˜ë¦¬

```kotlin
// ì˜ˆì‹œ: ê³µê°„ ì¿¼ë¦¬ ì²˜ë¦¬ íë¦„
fun processLocationVerification(claim: LocationClaim): VerificationResult {
    // 1. ìš”ì²­ êµ¬ì¡° ê²€ì¦ ë° ì¡°ì‘ ë°©ì§€ í™•ì¸
    validateLocationClaim(claim)
    
    // 2. PostGIS ì§€ì˜¤ë©”íŠ¸ë¦¬ë¡œ ë³€í™˜
    val userPoint = geometryFactory.createPoint(
        Coordinate(claim.coordinates.longitude, claim.coordinates.latitude)
    )
    
    // 3. ê±°ë¦¬ ê³„ì‚°ì„ í¬í•¨í•œ ê³µê°„ ì¿¼ë¦¬
    val nearbyPlaces = placeRepository.findWithinRadius(
        claim.coordinates.latitude,
        claim.coordinates.longitude,
        radiusMeters = 50.0
    )
    
    // 4. ê²€ì¦ì„ ìœ„í•œ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§
    val verifiedPlace = nearbyPlaces.firstOrNull { place ->
        place.isWithinVerificationRadius(userPoint) &&
        place.isActive &&
        !isRecentlyVisited(claim.userId, place.id)
    }
    
    // 5. êµ¬ì¡°í™”ëœ ê²°ê³¼ ë°˜í™˜
    return VerificationResult(
        success = verifiedPlace != null,
        placeId = verifiedPlace?.id,
        distance = verifiedPlace?.let { 
            ST_Distance(userPoint, it.location) 
        }
    )
}
```

---

## í†µí•© íŒ¨í„´

### ì™¸ë¶€ ì„œë¹„ìŠ¤ í†µí•© ì•„í‚¤í…ì²˜

#### Cloudflare R2 í†µí•© (íŒŒì¼ ìŠ¤í† ë¦¬ì§€)

```kotlin
@Configuration
class R2Config {
    @Bean
    fun s3Client(@Value("\${r2.access-key-id}") accessKey: String): S3Client {
        return S3Client.builder()
            .endpointOverride(URI.create("https://\${r2.account-id}.r2.cloudflarestorage.com"))
            .credentialsProvider(StaticCredentialsProvider.create(
                AwsBasicCredentials.create(accessKey, secretKey)
            ))
            .region(Region.AUTO)
            .build()
    }
}

@Service
class MediaService(private val s3Client: S3Client) {
    
    fun generatePresignedUploadUrl(filename: String): PresignedUploadUrl {
        val presignRequest = PutObjectPresignRequest.builder()
            .signatureDuration(Duration.ofMinutes(15))
            .putObjectRequest(PutObjectRequest.builder()
                .bucket(bucketName)
                .key("uploads/$filename")
                .contentType("image/jpeg")
                .build())
            .build()
            
        val presignedRequest = s3Presigner.presignPutObject(presignRequest)
        
        return PresignedUploadUrl(
            url = presignedRequest.url().toString(),
            fields = presignedRequest.signedHeaders(),
            expiresAt = OffsetDateTime.now().plus(Duration.ofMinutes(15))
        )
    }
}
```

#### OAuth í†µí•© (ì¸ì¦)

```kotlin
@Configuration
@EnableOAuth2Client
class SecurityConfig {
    
    @Bean
    fun oauth2UserService(): OAuth2UserService<OAuth2UserRequest, OAuth2User> {
        return DefaultOAuth2UserService().let { delegate ->
            OAuth2UserService { userRequest ->
                val oAuth2User = delegate.loadUser(userRequest)
                
                // EN: Custom user mapping logic
        // KO: ì‚¬ìš©ì ì •ì˜ ì‚¬ìš©ì ë§¤í•‘ ë¡œì§
                val registrationId = userRequest.clientRegistration.registrationId
                val userAttributes = when (registrationId) {
                    "google" -> GoogleUserAttributes(oAuth2User.attributes)
                    "apple" -> AppleUserAttributes(oAuth2User.attributes)
                    else -> throw IllegalArgumentException("Unknown provider: $registrationId") // EN: Unknown provider / KO: ì•Œ ìˆ˜ ì—†ëŠ” ì œê³µì
                }
                
                // EN: Create or update user in our system
                // KO: ì‹œìŠ¤í…œì—ì„œ ì‚¬ìš©ì ìƒì„± ë˜ëŠ” ì—…ë°ì´íŠ¸
                userService.createOrUpdateFromOAuth(userAttributes)
                
                DefaultOAuth2User(
                    setOf(SimpleGrantedAuthority("ROLE_USER")),
                    oAuth2User.attributes,
                    "sub"
                )
            }
        }
    }
}
```

### ë¶€íŒ¨ ë°©ì§€ ë ˆì´ì–´

**Pattern (íŒ¨í„´)**: Protect domain model from external service changes (ì™¸ë¶€ ì„œë¹„ìŠ¤ ë³€ê²½ìœ¼ë¡œë¶€í„° ë„ë©”ì¸ ëª¨ë¸ ë³´í˜¸)

```kotlin
// EN: Anti-corruption layer for OAuth providers
// KO: OAuth ì œê³µìë¥¼ ìœ„í•œ ë¶€íŒ¨ ë°©ì§€ ë ˆì´ì–´
interface UserProfileProvider {
    fun extractUserProfile(attributes: Map<String, Any>): ExternalUserProfile
}

class GoogleUserProfileProvider : UserProfileProvider {
    override fun extractUserProfile(attributes: Map<String, Any>): ExternalUserProfile {
        return ExternalUserProfile(
            externalId = attributes["sub"] as String,
            email = attributes["email"] as String,
            displayName = attributes["name"] as String,
            avatarUrl = attributes["picture"] as String?,
            emailVerified = attributes["email_verified"] as Boolean? ?: false
        )
    }
}

class AppleUserProfileProvider : UserProfileProvider {
    override fun extractUserProfile(attributes: Map<String, Any>): ExternalUserProfile {
        // EN: Apple-specific attribute mapping
        // KO: Apple ê³ ìœ  ì†ì„± ë§¤í•‘
        val email = attributes["email"] as String
        val name = (attributes["name"] as Map<String, String>?)?.let {
            "${it["firstName"]} ${it["lastName"]}"
        } ?: email.substringBefore("@")
        
        return ExternalUserProfile(
            externalId = attributes["sub"] as String,
            email = email,
            displayName = name,
            avatarUrl = null, // EN: Apple doesn't provide profile pictures / KO: Appleì€ í”„ë¡œí•„ ì‚¬ì§„ì„ ì œê³µí•˜ì§€ ì•ŠìŒ
            emailVerified = true // EN: Apple emails are pre-verified / KO: Apple ì´ë©”ì¼ì€ ì‚¬ì „ ê²€ì¦ë¨
        )
    }
}
```

### ì„œí‚· ë¸Œë ˆì´ì»¤ íŒ¨í„´

```kotlin
@Component
class ResilientExternalService {
    
    @CircuitBreaker(name = "cloudflare-r2", fallbackMethod = "uploadFallback")
    @TimeLimiter(name = "cloudflare-r2")
    fun uploadFile(file: MultipartFile): CompletableFuture<String> {
        return CompletableFuture.supplyAsync {
            s3Client.putObject(
                PutObjectRequest.builder()
                    .bucket(bucketName)
                    .key(generateKey(file))
                    .build(),
                RequestBody.fromInputStream(file.inputStream, file.size)
            ).eTag()
        }
    }
    
    fun uploadFallback(file: MultipartFile, ex: Exception): CompletableFuture<String> {
        logger.warn("Upload failed, using fallback", ex) // EN: Upload failed, using fallback / KO: ì—…ë¡œë“œ ì‹¤íŒ¨, ëŒ€ì²´ ë°©ë²• ì‚¬ìš©
        return CompletableFuture.completedFuture("fallback-url")
    }
}
```

---

## PostGISë¥¼ í™œìš©í•œ ê³µê°„ ë°ì´í„° ì•„í‚¤í…ì²˜

### PostGIS ê³µê°„ í™•ì¥

ì´ ì‹œìŠ¤í…œì€ ê³ ê¸‰ ê³µê°„ ì—°ì‚°ì„ ìœ„í•´ **PostGIS**ë¥¼ í™œìš©í•©ë‹ˆë‹¤:

```sql
-- EN: Enable PostGIS extensions
-- KO: PostGIS í™•ì¥ ê¸°ëŠ¥ í™œì„±í™”
CREATE EXTENSION IF NOT EXISTS postgis;
CREATE EXTENSION IF NOT EXISTS postgis_topology;

-- EN: Spatial data types and indexes
-- KO: ê³µê°„ ë°ì´í„° íƒ€ì… ë° ì¸ë±ìŠ¤
CREATE TABLE places (
    id UUID PRIMARY KEY,
    name VARCHAR(200) NOT NULL,
    location geography(Point, 4326) NOT NULL,  -- EN: WGS84 coordinate system / KO: WGS84 ì¢Œí‘œê³„
    verification_radius_m INTEGER DEFAULT 10,
    project_ids UUID[] NOT NULL,
    unit_ids UUID[] NOT NULL,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- EN: Spatial indexes for performance
-- KO: ì„±ëŠ¥ì„ ìœ„í•œ ê³µê°„ ì¸ë±ìŠ¤
CREATE INDEX idx_places_location_gist ON places USING GIST(location);
CREATE INDEX idx_places_project_ids_gin ON places USING GIN(project_ids);
CREATE INDEX idx_places_is_active ON places (is_active) WHERE is_active = true;

-- EN: Composite spatial + business logic index
-- KO: ë³µí•© ê³µê°„ + ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ì¸ë±ìŠ¤
CREATE INDEX idx_places_active_location ON places 
USING GIST(location) WHERE is_active = true;
```

### ê³µê°„ ì¿¼ë¦¬ íŒ¨í„´

#### ê±°ë¦¬ ê¸°ë°˜ ì¿¼ë¦¬
```kotlin
// EN: Find places within radius using PostGIS ST_DWithin
// KO: PostGIS ST_DWithinì„ ì‚¬ìš©í•˜ì—¬ ë°˜ê²½ ë‚´ ì¥ì†Œ ì°¾ê¸°
@Query("""
    SELECT p, ST_Distance(p.location, ST_Point(:longitude, :latitude, 4326)) as distance
    FROM PlaceEntity p 
    WHERE ST_DWithin(p.location, ST_Point(:longitude, :latitude, 4326), :radiusM)
    AND p.isActive = true
    ORDER BY ST_Distance(p.location, ST_Point(:longitude, :latitude, 4326))
    """)
fun findNearbyPlacesWithDistance(
    latitude: Double, 
    longitude: Double, 
    radiusM: Double
): List<Pair<PlaceEntity, Double>>
```

#### ê²½ê³„ ë°•ìŠ¤ ì¿¼ë¦¬
```kotlin
// EN: Efficient viewport queries using bounding box
// KO: ê²½ê³„ ë°•ìŠ¤ë¥¼ ì‚¬ìš©í•œ íš¨ìœ¨ì ì¸ ë·°í¬íŠ¸ ì¿¼ë¦¬
@Query("""
    SELECT p FROM PlaceEntity p 
    WHERE p.location && ST_MakeEnvelope(:minX, :minY, :maxX, :maxY, 4326)
    AND p.isActive = true
    AND (:projectIds IS NULL OR p.projectIds && CAST(:projectIds AS UUID[]))
    """)
fun findInBounds(
    minX: Double, minY: Double, 
    maxX: Double, maxY: Double,
    projectIds: List<UUID>?
): List<PlaceEntity>
```

#### ê³µê°„ ì§‘ê³„
```sql
-- EN: Region-based place clustering
-- KO: ì§€ì—­ ê¸°ë°˜ ì¥ì†Œ í´ëŸ¬ìŠ¤í„°ë§
SELECT 
    region_code,
    COUNT(*) as place_count,
    ST_Centroid(ST_Union(location)) as center_point,
    ST_Extent(location) as bounding_box
FROM places 
WHERE is_active = true 
GROUP BY region_code;
```

### ê³µê°„ ë°ì´í„° ë¬´ê²°ì„±

#### ì¡°ì‘ ë°©ì§€ ê²€ì¦
```kotlin
data class LocationClaim(
    val coordinates: Coordinates,
    val accuracy: Double,
    val timestamp: OffsetDateTime,
    val deviceSignature: String?
) {
    fun validateAntiTamper(previousClaim: LocationClaim?): ValidationResult {
        // EN: Speed check: detect impossible movement
        // KO: ì†ë„ í™•ì¸: ë¶ˆê°€ëŠ¥í•œ ì´ë™ ê°ì§€
        previousClaim?.let { prev ->
            val distance = calculateDistance(prev.coordinates, this.coordinates)
            val timeDiff = Duration.between(prev.timestamp, this.timestamp).seconds
            val speedMps = distance / timeDiff
            
            if (speedMps > MAX_HUMAN_SPEED_MPS) {
                return ValidationResult.invalid("Impossible movement speed: ${speedMps}m/s") // EN: Impossible movement speed / KO: ë¶ˆê°€ëŠ¥í•œ ì´ë™ ì†ë„
            }
        }
        
        // EN: Accuracy validation
        // KO: ì •í™•ë„ ê²€ì¦
        if (accuracy > MAX_ACCURACY_THRESHOLD) {
            return ValidationResult.invalid("GPS accuracy too poor: ${accuracy}m") // EN: GPS accuracy too poor / KO: GPS ì •í™•ë„ê°€ ë„ˆë¬´ ë‚®ìŒ
        }
        
        // Time validation (prevent replay attacks)
        val ageSeconds = Duration.between(timestamp, OffsetDateTime.now()).seconds
        if (ageSeconds > MAX_CLAIM_AGE_SECONDS) {
            return ValidationResult.invalid("Location claim too old: ${ageSeconds}s")
        }
        
        return ValidationResult.valid()
    }
}
```

### ì„±ëŠ¥ ìµœì í™”

#### ê³µê°„ ì¸ë±ìŠ¤ ì „ëµ
1. **GIST ì¸ë±ìŠ¤**: ì§€ì˜¤ë©”íŠ¸ë¦¬ ì»¬ëŸ¼ì„ ìœ„í•œ ê¸°ë³¸ ê³µê°„ ì¸ë±ìŠ¤ì…ë‹ˆë‹¤.
2. **ë¶€ë¶„ ì¸ë±ìŠ¤**: í™œì„± ìƒíƒœì˜ ì¥ì†Œë§Œ ì¸ë±ì‹±í•´ ì„±ëŠ¥ì„ ë†’ì…ë‹ˆë‹¤.
3. **ë³µí•© ì¸ë±ìŠ¤**: ê³µê°„ ì¡°ê±´ê³¼ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ í•„í„°ë¥¼ ê²°í•©í•©ë‹ˆë‹¤.
4. **ë°°ì—´ ì¸ë±ìŠ¤**: í”„ë¡œì íŠ¸/ìœ ë‹› ID í•„í„°ë§ì„ ìœ„í•œ GIN ì¸ë±ìŠ¤ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.

#### ì¿¼ë¦¬ ìµœì í™”
```kotlin
// Optimized service method with caching and efficient queries
@Cacheable("place:nearby", key = "#latitude + ',' + #longitude + ',' + #radiusKm")
fun findNearbyPlaces(
    latitude: Double, 
    longitude: Double, 
    radiusKm: Double = 1.0,
    projectIds: List<UUID>? = null,
    limit: Int = 50
): List<PlaceSummaryDto> {
    
    // Use smaller radius first for initial filtering
    val radiusM = radiusKm * 1000
    
    // Efficient spatial query with business logic filters
    return placeRepository.findNearbyWithFilters(
        latitude, longitude, radiusM, projectIds, limit
    ).map { (place, distance) ->
        PlaceSummaryDto(
            id = place.id,
            name = place.name,
            distance = distance,
            coordinates = Coordinates(
                place.location.y, // latitude
                place.location.x  // longitude
            )
        )
    }
}
```

---

## ìºì‹± ì „ëµ

### ë‹¤ë‹¨ê³„ ìºì‹± ì•„í‚¤í…ì²˜

ì´ ì‹œìŠ¤í…œì€ ë‹¤ìŒê³¼ ê°™ì€ **ì •êµí•œ 2ê³„ì¸µ ìºì‹± ì „ëµ**ì„ êµ¬í˜„í•©ë‹ˆë‹¤:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                Application                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚          L1: Caffeine (Local Cache)             â”‚
â”‚  â€¢ Ultra-fast memory cache (ì´ˆê³ ì† ë©”ëª¨ë¦¬ ìºì‹œ)                 â”‚
â”‚  â€¢ 1000 entries max, 1h TTL (ìµœëŒ€ 1000ê°œ í•­ëª©, 1ì‹œê°„ TTL)          â”‚
â”‚  â€¢ Method-level caching (ë©”ì†Œë“œ ìˆ˜ì¤€ ìºì‹œ)                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚           L2: Redis (Distributed)               â”‚
â”‚  â€¢ Shared across instances (ì¸ìŠ¤í„´ìŠ¤ ê°„ ê³µìœ )                      â”‚
â”‚  â€¢ Session storage (ì„¸ì…˜ ì €ì¥ì†Œ)                               â”‚
â”‚  â€¢ Rate limiting counters (ì†ë„ ì œí•œ ì¹´ìš´í„°)                      â”‚
â”‚  â€¢ Token blacklisting (í† í° ë¸”ë™ë¦¬ìŠ¤íŠ¸)                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚              PostgreSQL                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ìºì‹± ì„¤ì •

```kotlin
@Configuration
@EnableCaching
class CacheConfig {
    
    @Bean
    @Primary
    fun caffeineCacheManager(): CacheManager {
        return CaffeineCache.newBuilder()
            .maximumSize(1000)
            .expireAfterWrite(1, TimeUnit.HOURS)
            .recordStats()
            .buildCacheManager()
    }
    
    @Bean
    fun redisCacheManager(
        redisConnectionFactory: RedisConnectionFactory
    ): RedisCacheManager {
        return RedisCacheManager.builder(redisConnectionFactory)
            .cacheDefaults(
                RedisCacheConfiguration.defaultCacheConfig()
                    .entryTtl(Duration.ofHours(2))
                    .serializeKeysWith(StringRedisSerializer())
                    .serializeValuesWith(GenericJackson2JsonRedisSerializer())
            )
            .build()
    }
}
```

### ìºì‹œ ì‚¬ìš© íŒ¨í„´

#### Read-Through ìºì‹±
```kotlin
@Service
class PlaceService {
    
    // EN: L1 cache for frequently accessed place details
    // KO: ìì£¼ ì•¡ì„¸ìŠ¤ë˜ëŠ” ì¥ì†Œ ì„¸ë¶€ì •ë³´ë¥¼ ìœ„í•œ L1 ìºì‹œ
    @Cacheable("place:detail", key = "#placeId")
    fun getPlaceDetail(placeId: UUID): PlaceDetailDto {
        val place = placeRepository.findByIdOrThrow(placeId)
        // EN: Populate relationships efficiently
        // KO: íš¨ìœ¨ì ìœ¼ë¡œ ê´€ê³„ ë°ì´í„° ì±„ìš°ê¸°
        place.images = placeImageRepository.findByPlaceId(placeId).toMutableList()
        return place.toDetailDto()
    }
    
    // EN: Spatial queries with coordinate-based cache keys
    // KO: ì¢Œí‘œ ê¸°ë°˜ ìºì‹œ í‚¤ë¥¼ ì‚¬ìš©í•˜ëŠ” ê³µê°„ ì¿¼ë¦¬
    @Cacheable("place:nearby", key = "#lat + ',' + #lng + ',' + #radius")
    fun findNearbyPlaces(lat: Double, lng: Double, radius: Double): List<PlaceDto> {
        return placeRepository.findWithinRadius(lat, lng, radius)
            .map { it.toDto() }
    }
}
```

#### ìºì‹œ ì œê±°ê°€ í¬í•¨ëœ Write-Through
```kotlin
@Service
class PlaceService {
    
    @Transactional
    @CacheEvict(value = ["place:detail", "place:nearby"], key = "#placeId")
    fun updatePlace(placeId: UUID, request: UpdatePlaceRequest): PlaceDto {
        val place = placeRepository.findByIdOrThrow(placeId)
        place.apply {
            name = request.name
            description = request.description
            verificationRadiusM = request.verificationRadius
        }
        return placeRepository.save(place).toDto()
    }
    
    // EN: Batch cache eviction for complex operations
    // KO: ë³µì¡í•œ ì‘ì—…ì„ ìœ„í•œ ì¼ê´„ ìºì‹œ ì œê±°
    @CacheEvict(value = ["place:list"], allEntries = true)
    fun bulkImportPlaces(places: List<CreatePlaceRequest>): List<PlaceDto> {
        // EN: Bulk operation that affects list queries
        // KO: ëª©ë¡ ì¿¼ë¦¬ì— ì˜í–¥ì„ ì£¼ëŠ” ì¼ê´„ ì‘ì—…
        return placeRepository.saveAll(places.map { it.toEntity() })
            .map { it.toDto() }
    }
}
```

#### ì„¸ì…˜ ë° í† í° ê´€ë¦¬
```kotlin
@Service
class TokenRedisService(private val redisTemplate: RedisTemplate<String, String>) {
    
    fun blacklistToken(token: String, expirySeconds: Long) {
        redisTemplate.opsForValue().set(
            "blacklist:$token", 
            "revoked",
            Duration.ofSeconds(expirySeconds)
        )
    }
    
    fun isTokenBlacklisted(token: String): Boolean {
        return redisTemplate.hasKey("blacklist:$token")
    }
    
    // EN: Rate limiting with Redis counters
    // KO: Redis ì¹´ìš´í„°ë¥¼ ì‚¬ìš©í•œ ì†ë„ ì œí•œ
    fun incrementRateLimit(key: String, windowSeconds: Long): Long {
        val redisKey = "rate_limit:$key"
        return redisTemplate.opsForValue().increment(redisKey)?.also {
            if (it == 1L) {
                redisTemplate.expire(redisKey, Duration.ofSeconds(windowSeconds))
            }
        } ?: 0L
    }
}
```

### ìºì‹œ ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§

```kotlin
@Component
class CacheMetrics {
    
    @EventListener
    fun handleCacheHit(event: CacheHitEvent) {
        meterRegistry.counter("cache.hit", "name", event.cacheName).increment()
    }
    
    @EventListener
    fun handleCacheMiss(event: CacheMissEvent) {
        meterRegistry.counter("cache.miss", "name", event.cacheName).increment()
    }
    
    @Scheduled(fixedRate = 60000) // EN: Every minute / KO: ë§¤ë¶„
    fun reportCacheStatistics() {
        cacheManager.cacheNames.forEach { cacheName ->
            val cache = cacheManager.getCache(cacheName) as CaffeineCache?
            cache?.nativeCache?.stats()?.let { stats ->
                meterRegistry.gauge("cache.size", cacheName, stats.requestCount())
                meterRegistry.gauge("cache.hit_rate", cacheName, stats.hitRate())
                meterRegistry.gauge("cache.eviction_count", cacheName, stats.evictionCount())
            }
        }
    }
}
```

### ìºì‹œ ë¬´íš¨í™” ì „ëµ

1. **ì‹œê°„ ê¸°ë°˜ TTL**: ëŒ€ë¶€ë¶„ì˜ ìºì‹œ ë°ì´í„°ì— ìë™ ë§Œë£Œë¥¼ ì ìš©í•©ë‹ˆë‹¤.
2. **ì´ë²¤íŠ¸ ê¸°ë°˜**: ë°ì´í„° ë³€ê²½ ì‹œ ìˆ˜ë™ìœ¼ë¡œ ìºì‹œë¥¼ ì œê±°í•©ë‹ˆë‹¤.
3. **ë²„ì „ ê¸°ë°˜**: ì¼ê´€ì„±ì„ ìœ„í•´ ìºì‹œ í‚¤ì— ë²„ì „ ë²ˆí˜¸ë¥¼ í¬í•¨í•©ë‹ˆë‹¤.
4. **ê³„ë‹¨ì‹ ì œê±°**: ì—°ê´€ëœ ìºì‹œ í•­ëª©ì„ í•¨ê»˜ ë¬´íš¨í™”í•©ë‹ˆë‹¤.

**Cache Key Design Patterns (ìºì‹œ í‚¤ ë””ìì¸ íŒ¨í„´)**:
- **Hierarchical (ê³„ì¸µì )**: `user:profile:${userId}` for organized invalidation (ì¡°ì§ì  ë¬´íš¨í™”ë¥¼ ìœ„í•´)
- **Composite (ë³µí•©)**: `place:nearby:${lat},${lng},${radius}` for spatial queries (ê³µê°„ ì¿¼ë¦¬ë¥¼ ìœ„í•´)
- **Versioned (ë²„ì „ ê´€ë¦¬)**: `project:${id}:v${version}` for consistency (ì¼ê´€ì„±ì„ ìœ„í•´)

---

## ì´ë²¤íŠ¸ ê¸°ë°˜ íŒ¨í„´

### í˜„ì¬ ìƒíƒœ: ë™ê¸° ì²˜ë¦¬

í˜„ì¬ ì‹œìŠ¤í…œì€ **ë™ê¸° ìš”ì²­-ì‘ë‹µ íŒ¨í„´**ìœ¼ë¡œ ë™ì‘í•˜ì§€ë§Œ í–¥í›„ ì´ë²¤íŠ¸ ê¸°ë°˜ í™•ì¥ì„ ìœ„í•´ ì„¤ê³„ë˜ì–´ ìˆìŠµë‹ˆë‹¤:

```kotlin
// EN: Current synchronous approach
// KO: í˜„ì¬ì˜ ë™ê¸° ë°©ì‹
@Service
class PlaceVisitService {
    
    @Transactional
    fun recordVisit(userId: UUID, placeId: UUID, locationClaim: LocationClaim): VisitResult {
        // EN: Validate location claim
        // KO: ìœ„ì¹˜ í´ë ˆì„ ê²€ì¦
        val validation = validateLocationClaim(locationClaim, placeId)
        if (!validation.isValid) {
            return VisitResult.invalid(validation.reason)
        }
        
        // EN: Record visit synchronously
        // KO: ë™ê¸°ì ìœ¼ë¡œ ë°©ë¬¸ ê¸°ë¡
        val visitEvent = VisitEventEntity(
            userId = userId,
            placeId = placeId,
            location = locationClaim.toPoint(),
            verificationMethod = "gps",
            accuracy = locationClaim.accuracy
        )
        visitEventRepository.save(visitEvent)
        
        // EN: Update user statistics synchronously
        // KO: ë™ê¸°ì ìœ¼ë¡œ ì‚¬ìš©ì í†µê³„ ì—…ë°ì´íŠ¸
        userStatsService.incrementVisitCount(userId)
        
        // EN: Update place popularity synchronously
        // KO: ë™ê¸°ì ìœ¼ë¡œ ì¥ì†Œ ì¸ê¸°ë„ ì—…ë°ì´íŠ¸
        placeStatsService.incrementVisitCount(placeId)
        
        return VisitResult.success(visitEvent.id)
    }
}
```

### ê³„íšëœ ì´ë²¤íŠ¸ ê¸°ë°˜ ì•„í‚¤í…ì²˜

**Future enhancement with Spring Modulith events (Spring Modulith ì´ë²¤íŠ¸ë¡œ ë¯¸ë˜ í–¥ìƒ)**:

```kotlin
// EN: Domain events for decoupled processing
// KO: ë¶„ë¦¬ëœ ì²˜ë¦¬ë¥¼ ìœ„í•œ ë„ë©”ì¸ ì´ë²¤íŠ¸
sealed class DomainEvent {
    abstract val aggregateId: UUID
    abstract val occurredOn: OffsetDateTime
    abstract val eventId: UUID
}

data class PlaceVisitedEvent(
    override val aggregateId: UUID, // placeId
    override val occurredOn: OffsetDateTime,
    override val eventId: UUID = UUID.randomUUID(),
    val userId: UUID,
    val location: Point,
    val verificationAccuracy: Double
) : DomainEvent()

// Event-driven service with async processing
@Service
class PlaceVisitService {
    
    @Transactional
    @Async("visitProcessingExecutor")
    fun recordVisit(userId: UUID, placeId: UUID, locationClaim: LocationClaim): VisitResult {
        // EN: Core visit recording (synchronous)
        // KO: í•µì‹¬ ë°©ë¬¸ ê¸°ë¡ (ë™ê¸°)
        val validation = validateLocationClaim(locationClaim, placeId)
        if (!validation.isValid) {
            return VisitResult.invalid(validation.reason)
        }
        
        val visitEvent = visitEventRepository.save(
            VisitEventEntity(userId, placeId, locationClaim.toPoint())
        )
        
        // EN: Emit domain event for async processing
        // KO: ë¹„ë™ê¸° ì²˜ë¦¬ë¥¼ ìœ„í•œ ë„ë©”ì¸ ì´ë²¤íŠ¸ ë°œìƒ
        applicationEventPublisher.publishEvent(
            PlaceVisitedEvent(
                aggregateId = placeId,
                occurredOn = OffsetDateTime.now(),
                userId = userId,
                location = locationClaim.toPoint(),
                verificationAccuracy = locationClaim.accuracy
            )
        )
        
        return VisitResult.success(visitEvent.id)
    }
}

// EN: Async event handlers
// KO: ë¹„ë™ê¸° ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
@Component
class PlaceEventHandlers {
    
    @EventListener
    @Async("statisticsExecutor")
    fun handlePlaceVisited(event: PlaceVisitedEvent) {
        // EN: Update place popularity statistics
        // KO: ì¥ì†Œ ì¸ê¸°ë„ í†µê³„ ì—…ë°ì´íŠ¸
        placeStatsService.incrementVisitCount(event.aggregateId)
        
        // EN: Update regional statistics
        // KO: ì§€ì—­ í†µê³„ ì—…ë°ì´íŠ¸
        regionStatsService.incrementVisitCount(
            placeService.getRegionCode(event.aggregateId)
        )
    }
    
    @EventListener
    @Async("userStatsExecutor")
    fun updateUserStatistics(event: PlaceVisitedEvent) {
        // EN: Update user visit count
        // KO: ì‚¬ìš©ì ë°©ë¬¸ íšŸìˆ˜ ì—…ë°ì´íŠ¸
        userStatsService.incrementVisitCount(event.userId)
        
        // EN: Check for achievements/milestones
        // KO: ë‹¬ì„±/ë§ˆì¼ìŠ¤í†¤ í™•ì¸
        achievementService.checkVisitMilestones(event.userId)
        
        // EN: Update user ranking if applicable
        // KO: í•´ë‹¹ë˜ëŠ” ê²½ìš° ì‚¬ìš©ì ìˆœìœ„ ì—…ë°ì´íŠ¸
        rankingService.updateUserRanking(event.userId)
    }
    
    @EventListener
    @Async("notificationExecutor")
    fun sendNotifications(event: PlaceVisitedEvent) {
        // EN: Notify followers of user activity
        // KO: ì‚¬ìš©ì í™œë™ì„ íŒ”ë¡œì›Œë“¤ì—ê²Œ ì•Œë¦¼
        notificationService.notifyFollowers(
            event.userId, 
            "Visited ${placeService.getPlaceName(event.aggregateId)}"
        )
        
        // EN: Check for group challenges
        // KO: ê·¸ë£¹ ì±Œë¦°ì§€ í™•ì¸
        challengeService.updateGroupProgress(event.userId, event.aggregateId)
    }
}
```

### ì´ë²¤íŠ¸ ìŠ¤í† ì–´ ì„¤ê³„ (í–¥í›„)

```kotlin
// EN: Event sourcing pattern for audit and replay capability
// KO: ê°ì‚¬ ë° ì¬ìƒ ê¸°ëŠ¥ì„ ìœ„í•œ ì´ë²¤íŠ¸ ì†Œì‹± íŒ¨í„´
@Entity
@Table(name = "domain_events")
data class StoredDomainEvent(
    @Id val eventId: UUID = UUID.randomUUID(),
    val aggregateId: UUID,
    val eventType: String,
    @Column(columnDefinition = "jsonb")
    val eventData: String,
    val eventVersion: Int,
    val occurredOn: OffsetDateTime = OffsetDateTime.now(),
    val processedAt: OffsetDateTime? = null
)

@Repository
interface DomainEventStore : JpaRepository<StoredDomainEvent, UUID> {
    
    @Query("SELECT e FROM StoredDomainEvent e WHERE e.aggregateId = :aggregateId ORDER BY e.eventVersion")
    fun findByAggregateIdOrderByVersion(aggregateId: UUID): List<StoredDomainEvent>
    
    @Query("SELECT e FROM StoredDomainEvent e WHERE e.processedAt IS NULL ORDER BY e.occurredOn")
    fun findUnprocessedEvents(): List<StoredDomainEvent>
}
```

### ì´ë²¤íŠ¸ ê¸°ë°˜ ì•„í‚¤í…ì²˜ì˜ ì´ì 

1. **ê²°í•©ë„ ê°ì†Œ**: ì„œë¹„ìŠ¤ ê°„ ì§ì ‘ í˜¸ì¶œ ëŒ€ì‹  ì´ë²¤íŠ¸ë¥¼ í†µí•´ í†µì‹ í•©ë‹ˆë‹¤.
2. **í™•ì¥ì„± í–¥ìƒ**: ë¹„ë™ê¸° ì²˜ë¦¬ê°€ ì‘ë‹µ ì‹œê°„ì„ ë‹¨ì¶•í•©ë‹ˆë‹¤.
3. **ë³µì›ë ¥ í™•ë³´**: ì‹¤íŒ¨í•œ ì´ë²¤íŠ¸ ì²˜ë¦¬ëŠ” ë…ë¦½ì ìœ¼ë¡œ ì¬ì‹œë„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
4. **ì¶”ì  ê°€ëŠ¥ì„±**: ë””ë²„ê¹…ê³¼ ì»´í”Œë¼ì´ì–¸ìŠ¤ë¥¼ ìœ„í•œ ì™„ì „í•œ ì´ë²¤íŠ¸ ì´ë ¥ì„ í™•ë³´í•©ë‹ˆë‹¤.
5. **ìœ ì—°ì„± ê°•í™”**: ì‹ ê·œ ê¸°ëŠ¥ì´ ê¸°ì¡´ ì´ë²¤íŠ¸ë¥¼ êµ¬ë…í•˜ì—¬ ì‰½ê²Œ í™•ì¥í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

---

## ë³´ì•ˆ ì•„í‚¤í…ì²˜

### ë‹¤ì¸µ ë³´ì•ˆ í”„ë ˆì„ì›Œí¬

![ë‹¤ì¸µ ë³´ì•ˆ í”„ë ˆì„ì›Œí¬](https://mermaid.ink/img/VZBNa8MwDIbv-RWi19GVbddRyFfTjoyFxmyHsIOaGMfQOsFRNrJfP0dl8arDi-T3EZKsLPYtiCQAF8N4UlyvSlmPVtMEOU7SDiu25wgrYdEMfWcJ_qDnk91s90IU5UbkJTzcP30ufFSFxQEyJPmNV_DDocsj1RZM2yoNxFY7USkO6RtKdYfblQ8AdvM3Oo0cTRjurfzx5jMLYoa_SGc2yme9Jq4PpR4J3POvGt0USzb83z--qBAmhsB3JesFTU9upn0s3a49De3NC5vZqNEHeKeUM7lg-Mv1ytw1XWJom4CSE9XoLEWvMmrCmrDvWLPgF)

<details>
<summary>Mermaid ì›ë³¸ ì½”ë“œ ë³´ê¸°</summary>

```mermaid
graph TD
    subgraph "Security Layers" %% EN: Security Layers / KO: ë³´ì•ˆ ë ˆì´ì–´
        A["Transport Security<br/>HTTPS/TLS 1.3"] %% EN: Transport Security / KO: ì „ì†¡ ë³´ì•ˆ
        B["API Gateway<br/>Rate Limiting"] %% EN: API Gateway Rate Limiting / KO: API ê²Œì´íŠ¸ì›¨ì´ ì†ë„ ì œí•œ
        C["Authentication<br/>JWT + OAuth2"] %% EN: Authentication / KO: ì¸ì¦
        D["Authorization<br/>RBAC + Method Security"] %% EN: Authorization / KO: ê¶Œí•œ ë¶€ì—¬
        E["Input Validation<br/>Bean Validation"] %% EN: Input Validation / KO: ì…ë ¥ ê²€ì¦
        F["Data Protection<br/>Encryption + Hashing"] %% EN: Data Protection / KO: ë°ì´í„° ë³´í˜¸
        G["Audit Logging<br/>Security Events"] %% EN: Audit Logging / KO: ê°ì‚¬ ë¡œê¹…
    end
    
    A --> B --> C --> D --> E --> F --> G
```

<!-- ë³´ì•ˆ ê³„ì¸µ êµ¬ì¡° -->
![ë³´ì•ˆ ê³„ì¸µ êµ¬ì¡°](./diagrams/ì‹œìŠ¤í…œì•„í‚¤í…ì²˜_v2025.11.13_diagram_3.svg)

<!-- í˜¸í™˜ì„±ì„ ìœ„í•œ PNG ë²„ì „ -->
![ë³´ì•ˆ ê³„ì¸µ êµ¬ì¡° (PNG)](./images/ì‹œìŠ¤í…œì•„í‚¤í…ì²˜_v2025.11.13_diagram_3.png)


</details>

### ì¸ì¦ ë° ê¶Œí•œ ë¶€ì—¬

#### JWT í† í° ê´€ë¦¬
```kotlin
@Component
class JwtService(
    @Value("\${jwt.secret}") private val secret: String,
    @Value("\${jwt.access-token-expiration}") private val accessExpiration: Long,
    @Value("\${jwt.refresh-token-expiration}") private val refreshExpiration: Long
) {
    
    private val accessKey: SecretKey = Keys.hmacShaKeyFor(secret.toByteArray())
    
    fun generateAccessToken(user: UserEntity): String {
        return Jwts.builder()
            .setSubject(user.id.toString())
            .claim("role", user.role)
            .claim("email", user.email)
            .setIssuedAt(Date())
            .setExpiration(Date(System.currentTimeMillis() + accessExpiration * 1000))
            .signWith(accessKey)
            .compact()
    }
    
    fun validateToken(token: String): JwtValidationResult {
        return try {
            // EN: Check token blacklist first
            // KO: ë¨¼ì € í† í° ë¸”ë™ë¦¬ìŠ¤íŠ¸ í™•ì¸
            if (tokenRedisService.isTokenBlacklisted(token)) {
                return JwtValidationResult.invalid("Token has been revoked") // EN: Token has been revoked / KO: í† í°ì´ ì·¨ì†Œë¨
            }
            
            val claims = Jwts.parserBuilder()
                .setSigningKey(accessKey)
                .build()
                .parseClaimsJws(token)
                .body
            
            JwtValidationResult.valid(claims)
        } catch (ex: ExpiredJwtException) {
            JwtValidationResult.invalid("Token expired") // EN: Token expired / KO: í† í° ë§Œë£Œ
        } catch (ex: JwtException) {
            JwtValidationResult.invalid("Invalid token") // EN: Invalid token / KO: ìœ íš¨í•˜ì§€ ì•Šì€ í† í°
        }
    }
}
```

#### ì—­í•  ê¸°ë°˜ ì ‘ê·¼ ì œì–´
```kotlin
@Configuration
@EnableGlobalMethodSecurity(prePostEnabled = true)
class SecurityConfig {
    
    @Bean
    fun securityFilterChain(http: HttpSecurity): SecurityFilterChain {
        return http
            .csrf { it.disable() }
            .sessionManagement { it.sessionCreationPolicy(SessionCreationPolicy.STATELESS) }
            .authorizeHttpRequests { authz ->
                authz
                    // EN: Public endpoints
                    // KO: ê³µê°œ ì—”ë“œí¬ì¸íŠ¸
                    .requestMatchers("/api/v1/auth/**").permitAll()
                    .requestMatchers("/api/v1/projects/*/places").permitAll()
                    
                    // EN: User endpoints
                    // KO: ì‚¬ìš©ì ì—”ë“œí¬ì¸íŠ¸
                    .requestMatchers("/api/v1/users/**").hasRole("USER")
                    .requestMatchers("/api/v1/places/*/visits").hasRole("USER")
                    
                    // EN: Admin endpoints
                    // KO: ê´€ë¦¬ì ì—”ë“œí¬ì¸íŠ¸
                    .requestMatchers("/api/v1/admin/**").hasRole("ADMIN")
                    
                    // EN: Default authenticated
                    // KO: ê¸°ë³¸ ì¸ì¦ í•„ìš”
                    .anyRequest().authenticated()
            }
            .oauth2Login { oauth2 ->
                oauth2
                    .userInfoEndpoint { it.userService(customOAuth2UserService) }
                    .successHandler(oauth2SuccessHandler)
            }
            .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter::class.java)
            .build()
    }
}

// EN: Method-level security
// KO: ë©”ì†Œë“œ ìˆ˜ì¤€ ë³´ì•ˆ
@Service
class PlaceService {
    
    @PreAuthorize("@projectRoleService.hasRole(authentication.name, #projectId, 'EDITOR')")
    fun updatePlace(projectId: UUID, placeId: UUID, request: UpdatePlaceRequest): PlaceDto {
        // EN: Implementation
        // KO: êµ¬í˜„
    }
    
    @PostAuthorize("@placeSecurityService.canViewPlace(returnObject, authentication)")
    fun getPlaceDetail(placeId: UUID): PlaceDetailDto {
        // EN: Implementation
        // KO: êµ¬í˜„
    }
}
```

#### í”„ë¡œì íŠ¸ ë ˆë²¨ ê¶Œí•œ ë¶€ì—¬
```kotlin
@Component
class ProjectRoleService(
    private val projectRoleRepository: ProjectRoleRepository
) {
    
    fun hasRole(userSubject: String, projectId: UUID, requiredRole: String): Boolean {
        val userRoles = projectRoleRepository.findActiveRolesByUserAndProject(userSubject, projectId)
        return userRoles.any { it.role >= ProjectRole.valueOf(requiredRole) }
    }
    
    fun getUserProjectRoles(userSubject: String): Map<UUID, Set<ProjectRole>> {
        return projectRoleRepository.findActiveRolesByUser(userSubject)
            .groupBy({ it.projectId }, { it.role })
            .mapValues { it.value.toSet() }
    }
}

enum class ProjectRole {
    VIEWER, EDITOR, ADMIN;
    
    operator fun compareTo(other: ProjectRole): Int {
        return this.ordinal.compareTo(other.ordinal)
    }
}
```

### ì…ë ¥ ê²€ì¦ ë° ì •ì œ

```kotlin
// EN: Request DTOs with validation
// KO: ê²€ì¦ì´ í¬í•¨ëœ ìš”ì²­ DTO
data class CreatePlaceRequest(
    @field:NotBlank
    @field:Size(min = 1, max = 200)
    val name: String,
    
    @field:Valid
    val coordinates: CoordinatesDto,
    
    @field:Min(1)
    @field:Max(1000)
    val verificationRadius: Int = 10,
    
    @field:Pattern(regexp = "^[a-zA-Z0-9_-]+$")
    val placeType: String = "unknown"
)

data class CoordinatesDto(
    @field:DecimalMin("-90.0")
    @field:DecimalMax("90.0")
    val latitude: Double,
    
    @field:DecimalMin("-180.0")
    @field:DecimalMax("180.0")
    val longitude: Double
) {
    // EN: Custom validation for location tampering
    // KO: ìœ„ì¹˜ ì¡°ì‘ì— ëŒ€í•œ ì‚¬ìš©ì ì •ì˜ ê²€ì¦
    @AssertTrue(message = "Invalid coordinate precision")
    fun isValidPrecision(): Boolean {
        // EN: Prevent overly precise coordinates (potential tampering)
        // KO: ì§€ë‚˜ì¹˜ê²Œ ì •í™•í•œ ì¢Œí‘œ ë°©ì§€ (ì¡°ì‘ ê°€ëŠ¥ì„±)
        val latPrecision = latitude.toString().substringAfter(".").length
        val lngPrecision = longitude.toString().substringAfter(".").length
        return latPrecision <= 8 && lngPrecision <= 8
    }
}
```

### ë°ì´í„° ë³´í˜¸

#### íŒ¨ìŠ¤ì›Œë“œ ë³´ì•ˆ
```kotlin
@Component
class PasswordService(
    @Value("\${app.security.password.pepper}") private val pepper: String,
    @Value("\${app.security.password.bcrypt-strength}") private val strength: Int
) {
    
    private val bcryptEncoder = BCryptPasswordEncoder(strength)
    
    fun hashPassword(rawPassword: String): String {
        // EN: Add pepper for additional security layer
        // KO: ì¶”ê°€ ë³´ì•ˆ ë ˆì´ì–´ë¥¼ ìœ„í•œ pepper ì¶”ê°€
        val pepperedPassword = rawPassword + pepper
        return bcryptEncoder.encode(pepperedPassword)
    }
    
    fun verifyPassword(rawPassword: String, hashedPassword: String): Boolean {
        val pepperedPassword = rawPassword + pepper
        return bcryptEncoder.matches(pepperedPassword, hashedPassword)
    }
}
```

#### ë¯¼ê° ë°ì´í„° ì•”í˜¸í™”
```kotlin
@Component
class DataEncryptionService {
    
    @Value("\${encryption.key}")
    private lateinit var encryptionKey: String
    
    private val cipher = Cipher.getInstance("AES/GCM/NoPadding")
    private val secretKey by lazy { 
        SecretKeySpec(encryptionKey.toByteArray(), "AES") 
    }
    
    fun encrypt(data: String): String {
        cipher.init(Cipher.ENCRYPT_MODE, secretKey)
        val encryptedData = cipher.doFinal(data.toByteArray())
        val iv = cipher.iv
        return Base64.getEncoder().encodeToString(iv + encryptedData)
    }
    
    fun decrypt(encryptedData: String): String {
        val decoded = Base64.getDecoder().decode(encryptedData)
        val iv = decoded.sliceArray(0..11) // EN: GCM IV is 12 bytes / KO: GCM IVëŠ” 12ë°”ì´íŠ¸
        val cipherText = decoded.sliceArray(12 until decoded.size)
        
        val gcmSpec = GCMParameterSpec(128, iv)
        cipher.init(Cipher.DECRYPT_MODE, secretKey, gcmSpec)
        
        return String(cipher.doFinal(cipherText))
    }
}
```

### ê°ì‚¬ ë¡œê¹… ë° ë³´ì•ˆ ëª¨ë‹ˆí„°ë§

```kotlin
@Entity
@Table(name = "audit_logs")
data class AuditLogEntity(
    @Id val id: UUID = UUID.randomUUID(),
    val userId: UUID?,
    val userSubject: String?,
    val action: String,
    val resourceType: String,
    val resourceId: UUID?,
    @Column(columnDefinition = "jsonb")
    val details: String?,
    val ipAddress: String?,
    val userAgent: String?,
    val success: Boolean,
    val timestamp: OffsetDateTime = OffsetDateTime.now()
)

@Component
class SecurityAuditService(
    private val auditLogRepository: AuditLogRepository
) {
    
    fun logSecurityEvent(
        action: String,
        userId: UUID? = null,
        resourceType: String,
        resourceId: UUID? = null,
        success: Boolean = true,
        details: Any? = null,
        request: HttpServletRequest? = null
    ) {
        val auditLog = AuditLogEntity(
            userId = userId,
            userSubject = SecurityContextHolder.getContext().authentication?.name,
            action = action,
            resourceType = resourceType,
            resourceId = resourceId,
            details = details?.let { objectMapper.writeValueAsString(it) },
            ipAddress = request?.getClientIpAddress(),
            userAgent = request?.getHeader("User-Agent"),
            success = success
        )
        
        auditLogRepository.save(auditLog)
    }
    
    @EventListener
    fun handleAuthenticationSuccess(event: AuthenticationSuccessEvent) {
        logSecurityEvent(
            action = "AUTHENTICATION_SUCCESS",
            resourceType = "USER"
        )
    }
    
    @EventListener
    fun handleAuthenticationFailure(event: AbstractAuthenticationFailureEvent) {
        logSecurityEvent(
            action = "AUTHENTICATION_FAILURE",
            resourceType = "USER",
            success = false,
            details = mapOf("reason" to event.exception.message)
        )
    }
}
```

---

## í™•ì¥ì„± ê³ ë ¤ ì‚¬í•­

### ìˆ˜í‰ í™•ì¥ ì•„í‚¤í…ì²˜

![ìˆ˜í‰ í™•ì¥ ì•„í‚¤í…ì²˜](https://mermaid.ink/img/fVJda4MwFH33V4Q-tQ-lGF9HQW0pgnMuFsaQMq41s0KaSExh_ffTWLFGt7zdc89Hbm4KCdUFHT0LNae-ZYWuF6GAHHnAgJ-pRCHcqVxoSntCL42Kkv-gEeslk5ttkoToSOW15KBKwU9aQ3luGf5uVbHyrDmdO1omChRltK5XQ5Ibx3bacFHAa9WmILuLqWTJC-QJoU7PZDwm43_JzpgczZNnLu_D-dKSjGch-12Q2OmS0LysUSzLK8j76jTu475PqH6B1Z8pO1CQQU3NmPjwFZPg1SWf6TIWtSokTd7DPk8P8SFLRTeEQv4U3-jIPg4D37VHwsdFHi_bitAbZ_dZJZ5VRrPKmZESJSQUk4kITn0mbvk3A0mbStsdmMiAIX8XGXahh9brrf4aRo2N2ukELVND3YJ6DM9gzjNmDUsdYGx4DtsY-05xx8QnRv16Jk5mwzEa5qUINobExoDY-gU=)

<details>
<summary>Mermaid ì›ë³¸ ì½”ë“œ ë³´ê¸°</summary>

```mermaid
graph TB
    subgraph "Load Balancer Layer" %% EN: Load Balancer Layer / KO: ë¡œë“œë°¸ëŸ°ì„œ ë ˆì´ì–´
        LB["Nginx Load Balancer<br/>SSL Termination"] %% EN: SSL Termination / KO: SSL ì¢…ë£Œ
    end
    
    subgraph "Application Layer("Stateless")" %% EN: Application Layer Stateless / KO: ì• í”Œë¦¬ì¼€ì´ì…˜ ë ˆì´ì–´("ë¬´ìƒíƒœ")
        APP1["App Instance 1<br/>Spring Boot"] %% EN: App Instance / KO: ì•± ì¸ìŠ¤í„´ìŠ¤
        APP2["App Instance 2<br/>Spring Boot"] %% EN: App Instance / KO: ì•± ì¸ìŠ¤í„´ìŠ¤
        APP3["App Instance N<br/>Spring Boot"] %% EN: App Instance / KO: ì•± ì¸ìŠ¤í„´ìŠ¤
    end
    
    subgraph "Caching Layer" %% EN: Caching Layer / KO: ìºì‹œ ë ˆì´ì–´
        REDIS1["(Redis Primary)"] %% EN: Redis Primary / KO: Redis ì£¼ ì„œë²„
        REDIS2["(Redis Replica)"] %% EN: Redis Replica / KO: Redis ë³µì œ ì„œë²„
    end
    
    subgraph "Database Layer" %% EN: Database Layer / KO: ë°ì´í„°ë² ì´ìŠ¤ ë ˆì´ì–´
        PG_PRIMARY["(PostgreSQL Primary<br/>Write/Read)"] %% EN: Write/Read / KO: ì“°ê¸°/ì½ê¸°
        PG_REPLICA1["(PostgreSQL Replica 1<br/>Read Only)"] %% EN: Read Only / KO: ì½ê¸° ì „ìš©
        PG_REPLICA2["(PostgreSQL Replica N<br/>Read Only)"] %% EN: Read Only / KO: ì½ê¸° ì „ìš©
    end
    
    subgraph "Storage Layer" %% EN: Storage Layer / KO: ì €ì¥ì†Œ ë ˆì´ì–´
        R2["Cloudflare R2<br/>Global CDN"] %% EN: Global CDN / KO: ì „ì—­ CDN
    end
    
    LB --> APP1
    LB --> APP2 
    LB --> APP3
    
    APP1 --> REDIS1
    APP2 --> REDIS1
    APP3 --> REDIS1
    
    REDIS1 --> REDIS2
    
    APP1 --> PG_PRIMARY
    APP2 --> PG_PRIMARY
    APP3 --> PG_PRIMARY
    
    APP1 --> PG_REPLICA1
    APP2 --> PG_REPLICA1
    APP3 --> PG_REPLICA2
    
    APP1 --> R2
    APP2 --> R2
    APP3 --> R2
```

<!-- í™•ì¥ì„± ë° ë¡œë“œë°¸ëŸ°ì‹± êµ¬ì¡° -->
![í™•ì¥ì„± ë° ë¡œë“œë°¸ëŸ°ì‹± êµ¬ì¡°](./diagrams/ì‹œìŠ¤í…œì•„í‚¤í…ì²˜_v2025.11.13_diagram_4.svg)

<!-- í˜¸í™˜ì„±ì„ ìœ„í•œ PNG ë²„ì „ -->
![í™•ì¥ì„± ë° ë¡œë“œë°¸ëŸ°ì‹± êµ¬ì¡° (PNG)](./images/ì‹œìŠ¤í…œì•„í‚¤í…ì²˜_v2025.11.13_diagram_4.png)


</details>

### ë°ì´í„°ë² ì´ìŠ¤ í™•ì¥ ì „ëµ

#### ë¶€í•˜ ë¶„ì‚°ì´ í¬í•¨ëœ ì½ê¸° ë ˆí”Œë¦¬ì¹´
```kotlin
@Configuration
class DatabaseConfig {
    
    @Bean
    @Primary
    fun primaryDataSource(): DataSource {
        return HikariDataSource().apply {
            jdbcUrl = "jdbc:postgresql://primary-db:5432/girlsbandtabi"
            username = "app_user"
            password = "secure_password"
            maximumPoolSize = 20
            minimumIdle = 5
            connectionTimeout = 30000
            idleTimeout = 600000
            maxLifetime = 1800000
        }
    }
    
    @Bean
    fun replicaDataSource(): DataSource {
        return HikariDataSource().apply {
            jdbcUrl = "jdbc:postgresql://replica-db:5432/girlsbandtabi"
            username = "app_readonly"
            password = "secure_password"
            maximumPoolSize = 15
            isReadOnly = true
        }
    }
}

// EN: Read-write splitting with service annotations
// KO: ì„œë¹„ìŠ¤ ì–´ë…¸í…Œì´ì…˜ì„ ì‚¬ìš©í•œ ì½ê¸°-ì“°ê¸° ë¶„ë¦¬
@Service
@Transactional(readOnly = true) // EN: Default to read-only / KO: ê¸°ë³¸ì ìœ¼ë¡œ ì½ê¸° ì „ìš©
class PlaceService {
    
    @Transactional(readOnly = false) // EN: Explicit write operation / KO: ëª…ì‹œì  ì“°ê¸° ì‘ì—…
    fun createPlace(request: CreatePlaceRequest): PlaceDto {
        // EN: Write operations go to primary database
        // KO: ì“°ê¸° ì‘ì—…ì€ ê¸°ë³¸ ë°ì´í„°ë² ì´ìŠ¤ë¡œ ì´ë™
        return placeRepository.save(request.toEntity()).toDto()
    }
    
    // EN: Read operations can use read replicas
    // KO: ì½ê¸° ì‘ì—…ì€ ì½ê¸° ë³µì œë³¸ì„ ì‚¬ìš© ê°€ëŠ¥
    fun searchPlaces(criteria: PlaceSearchCriteria): List<PlaceDto> {
        return placeRepository.findByCriteria(criteria).map { it.toDto() }
    }
}
```

#### ì»¤ë„¥ì…˜ í’€ ìµœì í™”
```yaml
# application.yml - EN: Database connection tuning / KO: ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° íŠœë‹
spring:
  datasource:
    hikari:
      auto-commit: false
      connection-timeout: 30000      # EN: 30 seconds / KO: 30ì´ˆ
      idle-timeout: 600000           # EN: 10 minutes / KO: 10ë¶„  
      max-lifetime: 1800000          # EN: 30 minutes / KO: 30ë¶„
      maximum-pool-size: 20          # EN: Per instance / KO: ì¸ìŠ¤í„´ìŠ¤ë‹¹
      minimum-idle: 5
      leak-detection-threshold: 60000 # EN: 60 seconds / KO: 60ì´ˆ
      validation-timeout: 5000
  
  jpa:
    hibernate:
      jdbc:
        batch_size: 25               # EN: Batch inserts / KO: ì¼ê´„ ì‚½ì…
        fetch_size: 50               # EN: JDBC fetch size / KO: JDBC í˜ì¹˜ í¬ê¸°
    properties:
      hibernate:
        jdbc:
          time_zone: UTC
        connection:
          handling_mode: DELAYED_ACQUISITION_AND_RELEASE_AFTER_TRANSACTION
```

### ì• í”Œë¦¬ì¼€ì´ì…˜ ë ˆë²¨ í™•ì¥

#### ìƒíƒœ ë¹„ì €ì¥ ì• í”Œë¦¬ì¼€ì´ì…˜ ì„¤ê³„
```kotlin
@RestController
class PlaceController {
    
    // EN: No instance variables - fully stateless
    // KO: ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜ ì—†ìŒ - ì™„ì „íˆ ë¬´ìƒíƒœ
    // EN: All state comes from request parameters or external stores
    // KO: ëª¨ë“  ìƒíƒœëŠ” ìš”ì²­ ë§¤ê°œë³€ìˆ˜ ë˜ëŠ” ì™¸ë¶€ ì €ì¥ì†Œì—ì„œ ì œê³µ
    
    @GetMapping("/api/v1/places/nearby")
    fun findNearbyPlaces(
        @RequestParam lat: Double,
        @RequestParam lng: Double,
        @RequestParam radius: Double = 1.0,
        @RequestParam projectIds: List<UUID>? = null,
        authentication: Authentication? = null
    ): ResponseEntity<List<PlaceDto>> {
        
        // EN: User context from JWT token, not session
        // KO: ì„¸ì…˜ì´ ì•„ë‹Œ JWT í† í°ì—ì„œ ì‚¬ìš©ì ì»¨í…ìŠ¤íŠ¸
        val userId = authentication?.let { 
            UUID.fromString(it.name) 
        }
        
        // EN: Business logic delegated to stateless services
        // KO: ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì€ ë¬´ìƒíƒœ ì„œë¹„ìŠ¤ì— ìœ„ì„
        val places = placeService.findNearby(lat, lng, radius, projectIds, userId)
        
        return ResponseEntity.ok(places)
    }
}
```

#### ê³ ë¹„ìš© ì—°ì‚° ë¹„ë™ê¸° ì²˜ë¦¬
```kotlin
@Configuration
@EnableAsync
class AsyncConfig {
    
    @Bean("spatialProcessingExecutor")
    fun spatialProcessingExecutor(): Executor {
        return ThreadPoolTaskExecutor().apply {
            corePoolSize = 4
            maxPoolSize = 16
            queueCapacity = 100
            threadNamePrefix = "spatial-"
            setRejectedExecutionHandler(ThreadPoolExecutor.CallerRunsPolicy())
            initialize()
        }
    }
}

@Service
class PlaceAnalyticsService {
    
    @Async("spatialProcessingExecutor")
    fun updatePlacePopularityAsync(placeId: UUID): CompletableFuture<Void> {
        return CompletableFuture.supplyAsync {
            // EN: Heavy computational work
            // KO: ë¬´ê±°ìš´ ê³„ì‚° ì‘ì—…
            val popularity = calculatePlacePopularity(placeId)
            placeRepository.updatePopularityScore(placeId, popularity)
            null
        }
    }
    
    @Async("spatialProcessingExecutor")  
    fun generateHeatMapDataAsync(bounds: GeoBounds): CompletableFuture<HeatMapData> {
        return CompletableFuture.supplyAsync {
            // EN: CPU-intensive spatial aggregations
            // KO: CPU ì§‘ì•½ì  ê³µê°„ ì§‘ê³„
            placeRepository.aggregateVisitsInBounds(bounds)
                .let { generateHeatMapFromVisits(it) }
        }
    }
}
```

### ì„±ëŠ¥ ìµœì í™” Strategies (ì „ëµ)

#### ì¿¼ë¦¬ ìµœì í™”
```kotlin
// EN: Efficient spatial queries with proper indexing
// KO: ì ì ˆí•œ ì¸ë±ì‹±ì„ ì‚¬ìš©í•œ íš¨ìœ¨ì ì¸ ê³µê°„ ì¿¼ë¦¬
@Repository
interface PlaceRepository : JpaRepository<PlaceEntity, UUID> {
    
    @Query("""
        SELECT p FROM PlaceEntity p 
        WHERE p.location && ST_MakeEnvelope(:minX, :minY, :maxX, :maxY, 4326)
        AND ST_DWithin(p.location, ST_Point(:centerX, :centerY, 4326), :radiusM)
        AND p.isActive = true
        AND (:projectIds IS NULL OR p.projectIds && CAST(:projectIds AS UUID[]))
        ORDER BY ST_Distance(p.location, ST_Point(:centerX, :centerY, 4326))
        LIMIT :limit
        """)
    fun findInBoundsOptimized(
        minX: Double, minY: Double, maxX: Double, maxY: Double,
        centerX: Double, centerY: Double, radiusM: Double,
        projectIds: List<UUID>?, limit: Int
    ): List<PlaceEntity>
    
    // EN: Bulk operations for better performance
    // KO: ë” ë‚˜ì€ ì„±ëŠ¥ì„ ìœ„í•œ ì¼ê´„ ì‘ì—…
    @Modifying
    @Query("UPDATE PlaceEntity p SET p.popularityScore = :score WHERE p.id = :id")
    fun updatePopularityScore(id: UUID, score: Double)
    
    @Query("""
        SELECT NEW org.pyrimidines.dto.PlaceSummaryProjection(
            p.id, p.name, p.location, p.verificationRadiusM
        ) 
        FROM PlaceEntity p 
        WHERE p.projectId = :projectId AND p.isActive = true
        """)
    fun findSummariesByProject(projectId: UUID): List<PlaceSummaryProjection>
}
```

#### ë©”ëª¨ë¦¬ ê´€ë¦¬
```kotlin
@Configuration
class JvmConfig {
    
    @PostConstruct
    fun configureJvm() {
        // EN: JVM tuning for spatial operations
        // KO: ê³µê°„ ì—°ì‚°ì„ ìœ„í•œ JVM íŠœë‹
        System.setProperty("java.awt.headless", "true")
        
        // EN: GC tuning for low-latency requirements
        // KO: ë‚®ì€ ì§€ì—° ì‹œê°„ ìš”êµ¬ì‚¬í•­ì„ ìœ„í•œ GC íŠœë‹
        System.setProperty("XX:+UseG1GC", "true")
        System.setProperty("XX:MaxGCPauseMillis", "200")
        System.setProperty("XX:G1HeapRegionSize", "16m")
    }
}

// EN: Memory-efficient DTOs for list operations
// KO: ëª©ë¡ ì‘ì—…ì„ ìœ„í•œ ë©”ëª¨ë¦¬ íš¨ìœ¨ì  DTO
data class PlaceSummaryDto(
    val id: UUID,
    val name: String,
    val coordinates: Coordinates,
    val distance: Double? = null
) // EN: No heavy objects or collections / KO: ë¬´ê±°ìš´ ê°ì²´ë‚˜ ì»¶ë ‰ì…˜ ì—†ìŒ

// EN: Stream processing for large datasets
// KO: ëŒ€ìš©ëŸ‰ ë°ì´í„°ì…‹ì„ ìœ„í•œ ìŠ¤íŠ¸ë¦¼ ì²˜ë¦¬
@Service
class PlaceExportService {
    
    fun exportPlacesToCsv(projectId: UUID): ResponseEntity<StreamingResponseBody> {
        return ResponseEntity.ok()
            .header("Content-Type", "text/csv")
            .header("Content-Disposition", "attachment; filename=places.csv")
            .body { outputStream ->
                // EN: Stream processing to avoid memory issues
                // KO: ë©”ëª¨ë¦¬ ë¬¸ì œë¥¼ í”¼í•˜ê¸° ìœ„í•œ ìŠ¤íŠ¸ë¦¼ ì²˜ë¦¬
                placeRepository.streamByProjectId(projectId).use { stream ->
                    stream.forEach { place ->
                        outputStream.write(place.toCsvLine().toByteArray())
                        outputStream.flush()
                    }
                }
            }
    }
}
```

### ëª¨ë‹ˆí„°ë§ ë° ê°€ì‹œì„±

```kotlin
@Component
class PerformanceMetrics(
    private val meterRegistry: MeterRegistry
) {
    
    fun recordDatabaseQuery(operation: String, duration: Duration) {
        Timer.Sample.start(meterRegistry)
            .stop(Timer.builder("database.query.duration")
                .tag("operation", operation)
                .register(meterRegistry))
    }
    
    fun recordSpatialOperation(operation: String, pointCount: Int, duration: Duration) {
        meterRegistry.timer("spatial.operation.duration", "type", operation)
            .record(duration)
        meterRegistry.gauge("spatial.operation.points", pointCount.toDouble())
    }
    
    @EventListener
    fun handleCacheEvent(event: CacheHitEvent) {
        meterRegistry.counter("cache.operations", 
            "result", "hit", 
            "cache", event.cacheName
        ).increment()
    }
}
```

---

## ë°°í¬ íŒ¨í„´

### ì»¨í…Œì´ë„ˆ ì•„í‚¤í…ì²˜

#### ë©€í‹° ìŠ¤í…Œì´ì§€ Dockerfile ìµœì í™”
```dockerfile
# EN: Build stage / KO: ë¹Œë“œ ë‹¨ê³„
FROM gradle:8-jdk21 AS builder
WORKDIR /app
COPY build.gradle.kts settings.gradle.kts ./
COPY server/build.gradle.kts ./server/
# EN: Copy source / KO: ì†ŒìŠ¤ ë³µì‚¬
COPY server/src ./server/src
RUN gradle clean build -x test --no-daemon

# EN: Runtime stage / KO: ëŸ°íƒ€ì„ ë‹¨ê³„  
FROM openjdk:21-jre-slim AS runtime

# EN: Create non-root user / KO: ë¹„ë£¨íŠ¸ ì‚¬ìš©ì ìƒì„±
RUN groupadd -r appuser && useradd -r -g appuser appuser

# EN: Install dependencies / KO: ì˜ì¡´ì„± ì„¤ì¹˜
RUN apt-get update && apt-get install -y \
    curl \
    && rm -rf /var/lib/apt/lists/*

WORKDIR /app

# EN: Copy application JAR / KO: ì• í”Œë¦¬ì¼€ì´ì…˜ JAR ë³µì‚¬
COPY --from=builder /app/server/build/libs/*.jar app.jar

# EN: Create logs directory / KO: ë¡œê·¸ ë””ë ‰í† ë¦¬ ìƒì„±
RUN mkdir -p logs && chown -R appuser:appuser logs

# EN: Switch to non-root user / KO: ë¹„ë£¨íŠ¸ ì‚¬ìš©ìë¡œ ì „í™˜
USER appuser

# EN: Health check / KO: í—¬ìŠ¤ ì²´í¬
HEALTHCHECK --interval=30s --timeout=10s --start-period=60s --retries=3 \
    CMD curl -f http://localhost:8080/actuator/health || exit 1

# EN: JVM optimization for containers / KO: ì»¨í…Œì´ë„ˆë¥¼ ìœ„í•œ JVM ìµœì í™”
ENV JAVA_OPTS="-XX:+UseContainerSupport \
               -XX:MaxRAMPercentage=75.0 \
               -XX:+UseG1GC \
               -XX:MaxGCPauseMillis=200 \
               -Djava.security.egd=file:/dev/./urandom"

EXPOSE 8080

ENTRYPOINT ["sh", "-c", "java $JAVA_OPTS -jar app.jar"]
```

#### ê°œë°œìš© Docker Compose
```yaml
# docker-compose.yml - EN: Development Docker Compose / KO: ê°œë°œìš© Docker Compose
version: '3.8'

services:
  database:
    image: postgis/postgis:15-3.3
    platform: "linux/amd64"
    environment:
      POSTGRES_DB: girlsbandtabi
      POSTGRES_USER: girlsbandtabi  
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
    ports:
      - "5432:5432"
    volumes:
      - ./docker-data/postgres:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U girlsbandtabi -d girlsbandtabi"]
      interval: 10s
      timeout: 5s
      retries: 5

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    command: redis-server --appendonly yes
    volumes:
      - ./docker-data/redis:/data
    healthcheck:
      test: ["CMD-SHELL", "redis-cli ping"]
      interval: 10s
      timeout: 5s
      retries: 5

  app:
    build: 
      context: .
      dockerfile: Dockerfile
      target: runtime
    environment:
      SPRING_PROFILES_ACTIVE: docker
      DB_USERNAME: ${POSTGRES_USER:-girlsbandtabi}
      DB_PASSWORD: ${POSTGRES_PASSWORD}
      REDIS_HOST: redis
      JWT_SECRET: ${JWT_SECRET}
      # EN: Feature flags / KO: ê¸°ëŠ¥ í”Œë˜ê·¸
      FEATURE_FLAGS_ANTI_TAMPER_ENABLED: "${ANTI_TAMPER_ENABLED:-true}"
      # EN: R2 configuration / KO: R2 ì„¤ì •  
      R2_ACCOUNT_ID: ${R2_ACCOUNT_ID}
      R2_ACCESS_KEY_ID: ${R2_ACCESS_KEY_ID}
      R2_SECRET_ACCESS_KEY: ${R2_SECRET_ACCESS_KEY}
    ports:
      - "8080:8080"
    volumes:
      - ./logs:/app/logs
    depends_on:
      database:
        condition: service_healthy
      redis:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/actuator/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s

  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"  
    volumes:
      - ./deploy/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./deploy/ssl:/etc/nginx/ssl:ro
    depends_on:
      app:
        condition: service_healthy
    profiles:
      - production

networks:
  default:
    driver: bridge
```

### Kubernetes ë°°í¬ (í–¥í›„)

```yaml
# k8s/app-deployment.yaml - EN: Kubernetes Application Deployment / KO: Kubernetes ì• í”Œë¦¬ì¼€ì´ì…˜ ë°°í¬
apiVersion: apps/v1
kind: Deployment
metadata:
  name: girlsbandtabi-app
  labels:
    app: girlsbandtabi
    component: api
spec:
  replicas: 3
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 1
      maxSurge: 1
  selector:
    matchLabels:
      app: girlsbandtabi
      component: api
  template:
    metadata:
      labels:
        app: girlsbandtabi
        component: api
    spec:
      containers:
      - name: app
        image: girlsbandtabi:latest
        ports:
        - containerPort: 8080
          name: http
        env:
        - name: SPRING_PROFILES_ACTIVE
          value: "k8s"
        - name: DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: db-secrets
              key: password
        - name: JWT_SECRET
          valueFrom:
            secretKeyRef:
              name: jwt-secrets  
              key: secret
        resources:
          requests:
            memory: "512Mi"
            cpu: "250m"
          limits:
            memory: "1Gi"
            cpu: "1000m"
        livenessProbe:
          httpGet:
            path: /actuator/health
            port: 8080
          initialDelaySeconds: 60
          periodSeconds: 30
        readinessProbe:
          httpGet:
            path: /actuator/health/readiness
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        volumeMounts:
        - name: logs
          mountPath: /app/logs
      volumes:
      - name: logs
        emptyDir: {}
---
apiVersion: v1
kind: Service
metadata:
  name: girlsbandtabi-service
spec:
  selector:
    app: girlsbandtabi
    component: api
  ports:
  - port: 80
    targetPort: 8080
    protocol: TCP
  type: ClusterIP
```

### CI/CD íŒŒì´í”„ë¼ì¸

```yaml
# .github/workflows/deploy.yml - EN: GitHub Actions CI/CD Pipeline / KO: GitHub Actions CI/CD íŒŒì´í”„ë¼ì¸
name: Deploy

on:
  push:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgis/postgis:15-3.3
        env:
          POSTGRES_PASSWORD: test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up JDK 21
      uses: actions/setup-java@v4
      with:
        java-version: '21'
        distribution: 'temurin'
        
    - name: Cache Gradle packages
      uses: actions/cache@v3
      with:
        path: |
          ~/.gradle/caches
          ~/.gradle/wrapper
        key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
        
    - name: Run tests
      run: |
        ./gradlew clean test integrationTest
        
    - name: Run security scan
      run: |
        ./gradlew dependencyCheckAnalyze
        
    - name: Code quality check
      run: |
        ./gradlew detekt ktlintCheck

  build-and-deploy:
    needs: test
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    
    - name: Build Docker image
      run: |
        docker build -t girlsbandtabi:${{ github.sha }} .
        
    - name: Push to registry
      run: |
        echo ${{ secrets.DOCKER_PASSWORD }} | docker login -u ${{ secrets.DOCKER_USERNAME }} --password-stdin
        docker tag girlsbandtabi:${{ github.sha }} ${{ secrets.DOCKER_REGISTRY }}/girlsbandtabi:${{ github.sha }}
        docker push ${{ secrets.DOCKER_REGISTRY }}/girlsbandtabi:${{ github.sha }}
        
    - name: Deploy to staging
      run: |
        # EN: Deploy to staging environment
        # KO: ìŠ¤í…Œì´ì§• í™˜ê²½ì— ë°°í¬
        kubectl set image deployment/girlsbandtabi-app app=${{ secrets.DOCKER_REGISTRY }}/girlsbandtabi:${{ github.sha }} -n staging
```

### ì½”ë“œí˜• ì¸í”„ë¼ (Terraform)

```hcl
# infrastructure/main.tf - EN: Terraform Infrastructure as Code / KO: Terraform ì½”ë“œí˜• ì¸í”„ë¼
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

# EN: RDS PostgreSQL with PostGIS / KO: PostGISë¥¼ ì‚¬ìš©í•œ RDS PostgreSQL
resource "aws_db_instance" "main" {
  identifier     = "girlsbandtabi-db"
  engine         = "postgres"
  engine_version = "15.4"
  instance_class = "db.t3.micro"
  
  allocated_storage     = 20
  max_allocated_storage = 100
  storage_type         = "gp3"
  storage_encrypted    = true
  
  db_name  = "girlsbandtabi"
  username = "app_user"
  password = var.db_password
  
  backup_retention_period = 7
  backup_window          = "03:00-04:00"
  maintenance_window     = "sun:04:00-sun:05:00"
  
  skip_final_snapshot = true
  deletion_protection = false
  
  vpc_security_group_ids = [aws_security_group.db.id]
  db_subnet_group_name   = aws_db_subnet_group.main.name
  
  tags = {
    Name = "GirlsBandTabi DB"
    Environment = var.environment
  }
}

# EN: ElastiCache Redis / KO: ElastiCache Redis
resource "aws_elasticache_subnet_group" "main" {
  name       = "girlsbandtabi-cache-subnet"
  subnet_ids = var.private_subnet_ids
}

resource "aws_elasticache_cluster" "main" {
  cluster_id           = "girlsbandtabi-redis"
  engine              = "redis"
  node_type           = "cache.t3.micro"
  num_cache_nodes     = 1
  parameter_group_name = "default.redis7"
  port                = 6379
  
  subnet_group_name = aws_elasticache_subnet_group.main.name
  security_group_ids = [aws_security_group.cache.id]
  
  tags = {
    Name = "GirlsBandTabi Cache"
    Environment = var.environment
  }
}

# EN: ECS Fargate Service / KO: ECS Fargate ì„œë¹„ìŠ¤
resource "aws_ecs_cluster" "main" {
  name = "girlsbandtabi"
  
  setting {
    name  = "containerInsights"
    value = "enabled"
  }
}

resource "aws_ecs_task_definition" "app" {
  family                   = "girlsbandtabi"
  requires_compatibilities = ["FARGATE"]
  network_mode            = "awsvpc"
  cpu                     = 1024
  memory                  = 2048
  execution_role_arn      = aws_iam_role.ecs_execution.arn
  task_role_arn          = aws_iam_role.ecs_task.arn
  
  container_definitions = jsonencode([
    {
      name  = "app"
      image = "${var.docker_registry}/girlsbandtabi:latest"
      
      portMappings = [
        {
          containerPort = 8080
          hostPort      = 8080
          protocol      = "tcp"
        }
      ]
      
      environment = [
        {
          name  = "SPRING_PROFILES_ACTIVE"
          value = "aws"
        },
        {
          name  = "DB_HOST"
          value = aws_db_instance.main.address
        },
        {
          name  = "REDIS_HOST"
          value = aws_elasticache_cluster.main.cache_nodes[0].address
        }
      ]
      
      secrets = [
        {
          name      = "DB_PASSWORD"
          valueFrom = aws_secretsmanager_secret.db_password.arn
        },
        {
          name      = "JWT_SECRET"
          valueFrom = aws_secretsmanager_secret.jwt_secret.arn
        }
      ]
      
      logConfiguration = {
        logDriver = "awslogs"
        options = {
          awslogs-group         = aws_cloudwatch_log_group.app.name
          awslogs-region        = var.aws_region
          awslogs-stream-prefix = "ecs"
        }
      }
      
      healthCheck = {
        command = ["CMD-SHELL", "curl -f http://localhost:8080/actuator/health || exit 1"]
        interval = 30
        timeout = 5
        retries = 3
        startPeriod = 60
      }
    }
  ])
}
```

---

## ë¯¸ë˜ ë°œì „ ë¡œë“œë§µ

### 1ë‹¨ê³„: ê¸°ë°˜ ê°œì„  (2025ë…„ 1ë¶„ê¸°)

#### 1.1 Spring Modulith ë§ˆì´ê·¸ë ˆì´ì…˜
```kotlin
// EN: Target modular structure
// KO: ëŒ€ìƒ ëª¨ë“ˆëŸ¬ êµ¬ì¡°
@Modulith(
    displayName = "Girls Band Tabi",
    systemName = "girlsbandtabi"
)
class GirlsbandtabiApplication

@Module(
    displayName = "User Management",
    allowedDependencies = ["shared"]
)
package org.pyrimidines.girlsbandtabi.user

@Module(
    displayName = "Place Management", 
    allowedDependencies = ["shared", "user"]
)
package org.pyrimidines.girlsbandtabi.place

@Module(
    displayName = "Project Management",
    allowedDependencies = ["shared", "user"]
)
package org.pyrimidines.girlsbandtabi.project
```

#### 1.2 ì´ë²¤íŠ¸ ê¸°ë°˜ ì•„í‚¤í…ì²˜
```kotlin
// EN: Domain events with Spring Modulith
// KO: Spring Modulithë¥¼ ì‚¬ìš©í•œ ë„ë©”ì¸ ì´ë²¤íŠ¸
@DomainEvent
data class PlaceVisitedEvent(
    val userId: UUID,
    val placeId: UUID,
    val timestamp: OffsetDateTime
)

@ApplicationModuleListener
internal class UserStatsEventHandler {
    
    @EventListener
    fun handlePlaceVisited(event: PlaceVisitedEvent) {
        // EN: Update user statistics asynchronously
        // KO: ë¹„ë™ê¸°ë¡œ ì‚¬ìš©ì í†µê³„ ì—…ë°ì´íŠ¸
        userStatsService.incrementVisitCount(event.userId)
    }
}
```

#### 1.3 API ë²„ì „ ê´€ë¦¬ ì „ëµ
```kotlin
// EN: Version-aware controllers
// KO: ë²„ì „ ì¸ì‹ ì»¨íŠ¸ë¡¤ëŸ¬
@RestController
@RequestMapping("/api/v1")
class PlaceControllerV1 {
    // EN: Current implementation
    // KO: í˜„ì¬ êµ¬í˜„
}

@RestController  
@RequestMapping("/api/v2")
class PlaceControllerV2 {
    // EN: Enhanced geospatial features
    // KO: í–¥ìƒëœ ì§€ë¦¬ê³µê°„ ê¸°ëŠ¥
    // EN: Improved response formats
    // KO: ê°œì„ ëœ ì‘ë‹µ í˜•ì‹
    // EN: Additional filtering options
    // KO: ì¶”ê°€ í•„í„°ë§ ì˜µì…˜
}
```

### 2ë‹¨ê³„: ì„±ëŠ¥ ë° í™•ì¥ì„± (2025ë…„ 2ë¶„ê¸°)

#### 2.1 ì½ê¸° ë ˆí”Œë¦¬ì¹´ í†µí•©
```kotlin
@Configuration
class MultiDataSourceConfig {
    
    @Primary
    @Bean
    fun writeDataSource(): DataSource {
        // EN: Primary database for writes
        // KO: ì“°ê¸°ë¥¼ ìœ„í•œ ê¸°ë³¸ ë°ì´í„°ë² ì´ìŠ¤
    }
    
    @Bean  
    fun readDataSource(): DataSource {
        // EN: Read replica for queries
        // KO: ì¿¼ë¦¬ë¥¼ ìœ„í•œ ì½ê¸° ë³µì œë³¸
    }
    
    @Bean
    fun routingDataSource(): DataSource {
        return LazyConnectionDataSourceProxy(
            DetermineCurrentDataSourceRoutingDataSource()
        )
    }
}

// EN: Automatic read/write routing
// KO: ìë™ ì½ê¸°/ì“°ê¸° ë¼ìš°íŒ…
@Service
@Transactional(readOnly = true) // EN: Default to read replica / KO: ê¸°ë³¸ì ìœ¼ë¡œ ì½ê¸° ë³µì œë³¸ ì‚¬ìš©
class PlaceService {
    
    @Transactional(readOnly = false) // EN: Route to primary / KO: ê¸°ë³¸ DBë¡œ ë¼ìš°íŒ…
    fun createPlace(request: CreatePlaceRequest): PlaceDto {
        // EN: Write operation
        // KO: ì“°ê¸° ì‘ì—…
    }
    
    // EN: Read operations use replica
    // KO: ì½ê¸° ì‘ì—…ì€ ë³µì œë³¸ ì‚¬ìš©
    fun searchPlaces(criteria: PlaceSearchCriteria): List<PlaceDto> {
        // EN: Read operation
        // KO: ì½ê¸° ì‘ì—…  
    }
}
```

#### 2.2 ë¶„ì‚° ìºì‹±
```kotlin
@Configuration
class DistributedCacheConfig {
    
    @Bean
    fun l2CacheManager(): CacheManager {
        return RedisCacheManager.builder(redisConnectionFactory)
            .cacheDefaults(
                RedisCacheConfiguration.defaultCacheConfig()
                    .entryTtl(Duration.ofHours(1))
                    .computePrefixWith(cacheName -> "girlsbandtabi:$cacheName:")
            )
            .build()
    }
    
    @Bean
    fun multiLevelCacheManager(): CacheManager {
        return CompositeCacheManager(
            caffeineCacheManager(), // L1: Local
            l2CacheManager()        // EN: L2: Distributed / KO: L2: ë¶„ì‚°
        )
    }
}
```

#### 2.3 ê³µê°„ ì¸ë±ìŠ¤ ìµœì í™”
```sql
-- EN: Advanced spatial indexing
-- KO: ê³ ê¸‰ ê³µê°„ ì¸ë±ì‹±
CREATE INDEX CONCURRENTLY idx_places_compound_spatial 
ON places USING GIST(location, project_ids) 
WHERE is_active = true;

-- EN: Partial indexes for performance
-- KO: ì„±ëŠ¥ì„ ìœ„í•œ ë¶€ë¶„ ì¸ë±ìŠ¤
CREATE INDEX CONCURRENTLY idx_places_popular 
ON places (popularity_score DESC, location) 
WHERE popularity_score > 0.5 AND is_active = true;

-- EN: Time-based partitioning for visit events
-- KO: ë°©ë¬¸ ì´ë²¤íŠ¸ë¥¼ ìœ„í•œ ì‹œê°„ ê¸°ë°˜ íŒŒí‹°ì…”ë‹
CREATE TABLE visit_events_2025 PARTITION OF visit_events
FOR VALUES FROM ('2025-01-01') TO ('2026-01-01');
```

### 3ë‹¨ê³„: ê³ ê¸‰ ê¸°ëŠ¥ (2025ë…„ 3ë¶„ê¸°)

#### 3.1 WebSocketì„ í™œìš©í•œ ì‹¤ì‹œê°„ ê¸°ëŠ¥
```kotlin
@Configuration
@EnableWebSocket
class WebSocketConfig : WebSocketConfigurer {
    
    override fun registerWebSocketHandlers(registry: WebSocketHandlerRegistry) {
        registry.addHandler(PlaceActivityHandler(), "/ws/places/{placeId}")
            .setAllowedOrigins("*")
            .withSockJS()
    }
}

@Component
class PlaceActivityHandler : TextWebSocketHandler() {
    
    override fun afterConnectionEstablished(session: WebSocketSession) {
        val placeId = extractPlaceId(session.uri)
        subscribeToPlaceActivity(placeId, session)
    }
    
    fun broadcastVisitActivity(placeId: UUID, visitInfo: VisitActivityDto) {
        getSubscribedSessions(placeId).forEach { session ->
            session.sendMessage(TextMessage(objectMapper.writeValueAsString(visitInfo)))
        }
    }
}
```

#### 3.2 ë¨¸ì‹ ëŸ¬ë‹ í†µí•©
```kotlin
@Component
class PlaceRecommendationEngine {
    
    fun getPersonalizedRecommendations(
        userId: UUID, 
        location: Point,
        limit: Int = 10
    ): List<PlaceRecommendationDto> {
        
        // EN: User behavior analysis
        // KO: ì‚¬ìš©ì í–‰ë™ ë¶„ì„
        val userPreferences = analyzeUserPreferences(userId)
        
        // EN: Collaborative filtering
        // KO: í˜‘ì—… í•„í„°ë§
        val similarUsers = findSimilarUsers(userId)
        
        // EN: Location-based scoring
        // KO: ìœ„ì¹˜ ê¸°ë°˜ ì ìˆ˜ ë§¤ê¸°ê¸°
        val nearbyPlaces = placeService.findNearby(location, radiusKm = 10.0)
        
        // EN: ML scoring algorithm
        // KO: ë¨¸ì‹ ëŸ¬ë‹ ì ìˆ˜ ì•Œê³ ë¦¬ì¦˜
        return nearbyPlaces.map { place ->
            val score = calculateRecommendationScore(
                place, userPreferences, similarUsers, location
            )
            PlaceRecommendationDto(place, score)
        }
        .sortedByDescending { it.score }
        .take(limit)
    }
}
```

#### 3.3 ê³ ê¸‰ ë¶„ì„
```kotlin
@Service
class AdvancedAnalyticsService {
    
    fun generateHeatMap(bounds: GeoBounds, timeRange: TimeRange): HeatMapData {
        // EN: Spatial-temporal analysis
        // KO: ì‹œê³µê°„ ë¶„ì„
        val visits = visitEventRepository.findInBoundsAndTimeRange(bounds, timeRange)
        
        // EN: Density clustering
        // KO: ë°€ë„ í´ëŸ¬ìŠ¤í„°ë§
        val clusters = performDBSCANClustering(visits)
        
        return HeatMapData(
            bounds = bounds,
            intensityPoints = clusters.map { cluster ->
                IntensityPoint(
                    location = cluster.centroid,
                    intensity = cluster.visitCount.toDouble() / visits.size
                )
            }
        )
    }
    
    fun predictPopularTimes(placeId: UUID): PopularTimesDto {
        // EN: Time series analysis of visit patterns
        // KO: ë°©ë¬¸ íŒ¨í„´ì˜ ì‹œê³„ì—´ ë¶„ì„
        val historicalData = visitEventRepository.getHourlyVisitCounts(placeId)
        
        // EN: Apply time series forecasting
        // KO: ì‹œê³„ì—´ ì˜ˆì¸¡ ì ìš©
        val predictions = timeSeriesPredictor.predict(historicalData)
        
        return PopularTimesDto(
            placeId = placeId,
            hourlyPredictions = predictions.mapIndexed { hour, prediction ->
                HourlyPrediction(hour, prediction.toInt())
            }
        )
    }
}
```

### 4ë‹¨ê³„: í´ë¼ìš°ë“œ ë„¤ì´í‹°ë¸Œ ë§ˆì´ê·¸ë ˆì´ì…˜ (2025ë…„ 4ë¶„ê¸°)

#### 4.1 Kubernetes ë„¤ì´í‹°ë¸Œ ë°°í¬
```yaml
# Helm chart values - EN: Helm Chart Configuration / KO: Helm ì°¨íŠ¸ ì„¤ì •
replicaCount: 3

autoscaling:
  enabled: true
  minReplicas: 3
  maxReplicas: 10
  targetCPUUtilizationPercentage: 70
  targetMemoryUtilizationPercentage: 80

resources:
  limits:
    cpu: 1000m
    memory: 1Gi
  requests:
    cpu: 500m
    memory: 512Mi

persistence:
  enabled: true
  storageClass: "gp3"
  size: 100Gi

monitoring:
  enabled: true
  prometheus: true
  grafana: true
  jaeger: true
```

#### 4.2 ì„œë¹„ìŠ¤ ë©”ì‹œ í†µí•©
```yaml
# Istio service mesh configuration - EN: Service Mesh Configuration / KO: ì„œë¹„ìŠ¤ ë©”ì‹œ ì„¤ì •
apiVersion: networking.istio.io/v1beta1
kind: VirtualService
metadata:
  name: girlsbandtabi
spec:
  http:
  - match:
    - uri:
        prefix: /api/v1
    route:
    - destination:
        host: girlsbandtabi-service
    retries:
      attempts: 3
      perTryTimeout: 2s
    timeout: 10s
  - fault:
      delay:
        percentage:
          value: 0.1
        fixedDelay: 5s
```

#### 4.3 ê´€ì¸¡ ê°€ëŠ¥ì„± í–¥ìƒ
```kotlin
@Configuration
class ObservabilityConfig {
    
    @Bean
    fun meterRegistry(): MeterRegistry {
        return CompositeMeterRegistry().apply {
            add(PrometheusMeterRegistry.builder()
                .commonTags("service", "girlsbandtabi")
                .build())
        }
    }
    
    @Bean
    fun tracingExecutor(): Executor {
        return TracingExecutor(Executors.newFixedThreadPool(10))
    }
}

// EN: Distributed tracing
// KO: ë¶„ì‚° ì¶”ì 
@Service
class TracedPlaceService {
    
    @NewSpan("place.search")
    fun searchPlaces(
        @SpanTag("criteria") criteria: PlaceSearchCriteria
    ): List<PlaceDto> {
        return Span.current().addEvent("search.start").let {
            val results = placeRepository.findByCriteria(criteria)
            Span.current()
                .addEvent("search.complete")
                .setAttribute("results.count", results.size)
            results.map { it.toDto() }
        }
    }
}
```

---

## ê²°ë¡ 

Girls Band Tabi ì•„í‚¤í…ì²˜ëŠ” ê²€ì¦ëœ Spring ìƒíƒœê³„ ê¸°ìˆ ì„ ê¸°ë°˜ìœ¼ë¡œ êµ¬ì¶•ëœ **ì„±ìˆ™í•˜ê³  í”„ë¡œë•ì…˜ ì¤€ë¹„ê°€ ì™„ë£Œëœ í”Œë«í¼**ì„ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤. í˜„ì¬ì˜ MVC + JPA êµ¬í˜„ì€ ë‹¤ìŒì„ ì œê³µí•©ë‹ˆë‹¤:

### ê°•ì 
- **ì•ˆì •ì„±**: í¬ê´„ì ì¸ ì˜¤ë¥˜ ì²˜ë¦¬ê°€ í¬í•¨ëœ ì‹¤ì „ ê²€ì¦ëœ Spring Boot ìŠ¤íƒ
- **ì„±ëŠ¥**: ë‹¤ì¤‘ ë ˆë²¨ ìºì‹±ê³¼ ìµœì í™”ëœ ê³µê°„ ì¿¼ë¦¬
- **ë³´ì•ˆ**: ì¸ì¦, ê¶Œí•œ ë¶€ì—¬, ê°ì‚¬ ë¡œê¹…ì„ í†µí•œ ì‹¬ì¸µ ë°©ì–´
- **ìœ ì§€ë³´ìˆ˜ì„±**: ê´€ì‹¬ì‚¬ì˜ ëª…í™•í•œ ë¶„ë¦¬ë¥¼ í†µí•œ ê¹”ë”í•œ ì•„í‚¤í…ì²˜
- **í™•ì¥ì„±**: ìˆ˜í‰ì  í™•ì¥ ì¤€ë¹„ê°€ ì™„ë£Œëœ ë¬´ìƒíƒœ ì„¤ê³„

### ë°œì „ ê²½ë¡œ
**Spring Modulith ë° ì´ë²¤íŠ¸ ê¸°ë°˜ ì•„í‚¤í…ì²˜**ë¡œì˜ ë¡œë“œë§µì€ ë‹¤ìŒê³¼ ê°™ì€ ëª…í™•í•œ ë§ˆì´ê·¸ë ˆì´ì…˜ ì „ëµì„ ì œê³µí•©ë‹ˆë‹¤:
- ì „í™˜ ì¤‘ ê¸°ì¡´ ê¸°ëŠ¥ ë³´ì¡´
- í˜¸í™˜ì„±ì„ ê¹¨ëœ¨ë¦¬ì§€ ì•ŠëŠ” ëª¨ë“ˆì„± ë„ì…
- ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ ë° ML í†µí•©ê³¼ ê°™ì€ ê³ ê¸‰ ê¸°ëŠ¥ í™œì„±í™”
- í´ë¼ìš°ë“œ ë„¤ì´í‹°ë¸Œ ë°°í¬ íŒ¨í„´ ì§€ì›

### ì£¼ìš” ì•„í‚¤í…ì²˜ ê²°ì •
1. **WebFlux ëŒ€ì‹  MVC**: ì¼ê´€ì„±ê³¼ ìƒíƒœê³„ ì„±ìˆ™ë„ ì„ íƒ
2. **R2DBC ëŒ€ì‹  JPA**: ê³µê°„ ê¸°ëŠ¥ì„ ìœ„í•œ ì™„ì „í•œ PostGIS í†µí•©
3. **ì• í”Œë¦¬ì¼€ì´ì…˜ ê´€ë¦¬ ê´€ê³„**: ëª…ì‹œì  í˜ì¹­ìœ¼ë¡œ N+1 ì¿¼ë¦¬ ë°©ì§€
4. **ë‹¤ì¤‘ ë ˆë²¨ ìºì‹±**: ìµœì  ì„±ëŠ¥ì„ ìœ„í•œ Caffeine L1 + Redis L2
5. **ë³´ì•ˆ ìš°ì„  ì„¤ê³„**: í¬ê´„ì ì¸ ì¸ì¦, ê¶Œí•œ ë¶€ì—¬, ê°ì‚¬ ì¶”ì 

ì´ ì•„í‚¤í…ì²˜ëŠ” **í˜„ì¬ ìš´ì˜ ìš”êµ¬ì‚¬í•­**ê³¼ **ë¯¸ë˜ í™•ì¥ì„± ìš”êµ¬ì‚¬í•­** ì‚¬ì´ì˜ ê· í˜•ì„ ì„±ê³µì ìœ¼ë¡œ ë§ì¶”ì–´, Girls Band Tabi í”Œë«í¼ì˜ ì§€ì†ì ì¸ ì„±ì¥ê³¼ ë°œì „ì„ ìœ„í•œ ê²¬ê³ í•œ ê¸°ë°˜ì„ ì œê³µí•©ë‹ˆë‹¤.

---

**ë‹¤ìŒ ë‹¨ê³„**:
1. ê°œë°œíŒ€ê³¼ í•¨ê»˜ ì´ ë¬¸ì„œ ê²€í† 
2. 1ë‹¨ê³„ êµ¬í˜„ì„ ìœ„í•œ ìš°ì„ ìˆœìœ„ ì˜ì—­ ì‹ë³„
3. ì„ íƒëœ ê°œì„ ì‚¬í•­ì— ëŒ€í•œ ìƒì„¸ êµ¬í˜„ ê³„íš ìˆ˜ë¦½
4. ì•„í‚¤í…ì²˜ ê±´ì „ì„±ì„ ìœ„í•œ ë©”íŠ¸ë¦­ ë° ëª¨ë‹ˆí„°ë§ êµ¬ì¶•

**ë¬¸ì„œ ìœ ì§€ë³´ìˆ˜**:
- ì •í™•ì„±ê³¼ ê´€ë ¨ì„±ì„ ìœ„í•œ ë¶„ê¸°ë³„ ê²€í† 
- ì£¼ìš” ì•„í‚¤í…ì²˜ ë³€ê²½ í›„ ì—…ë°ì´íŠ¸
- ADR í˜•ì‹ì˜ ë²„ì „ ì´ë ¥ ìœ ì§€
